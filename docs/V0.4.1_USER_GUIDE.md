# LangChain-Go v0.4.1 ç”¨æˆ·æŒ‡å—

**ç‰ˆæœ¬**: v0.4.1  
**å‘å¸ƒæ—¥æœŸ**: 2026-01-21  
**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæ•´  

---

## ğŸ“š ç›®å½•

1. [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
2. [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
3. [å›¾æ•°æ®åº“](#å›¾æ•°æ®åº“)
4. [çŸ¥è¯†å›¾è°±æ„å»º](#çŸ¥è¯†å›¾è°±æ„å»º)
5. [GraphRAG æ£€ç´¢](#graphrag-æ£€ç´¢)
6. [è¿›é˜¶ä½¿ç”¨](#è¿›é˜¶ä½¿ç”¨)
7. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
8. [æ•…éšœæ’é™¤](#æ•…éšœæ’é™¤)
9. [FAQ](#faq)

---

## ğŸš€ å¿«é€Ÿå¼€å§‹

### å®‰è£…

```bash
go get github.com/zhucl121/langchain-go@v0.4.1
```

### 30ç§’å¿«é€Ÿä½“éªŒ

```go
package main

import (
	"context"
	"fmt"
	
	"github.com/zhucl121/langchain-go/retrieval/graphdb/mock"
	"github.com/zhucl121/langchain-go/retrieval/graphdb/builder"
	"github.com/zhucl121/langchain-go/retrieval/retrievers/graphrag"
	"github.com/zhucl121/langchain-go/retrieval/vectorstores"
)

func main() {
	ctx := context.Background()
	
	// 1. åˆ›å»ºå›¾æ•°æ®åº“ï¼ˆä½¿ç”¨ Mockï¼‰
	graphDB := mock.NewMockGraphDB()
	graphDB.Connect(ctx)
	defer graphDB.Close()
	
	// 2. åˆ›å»ºå‘é‡å­˜å‚¨
	embeddings := newMockEmbeddings(384)
	vectorStore := vectorstores.NewInMemoryVectorStore(embeddings)
	
	// 3. åˆ›å»º GraphRAG æ£€ç´¢å™¨
	config := graphrag.DefaultConfig(graphDB, vectorStore)
	retriever, _ := graphrag.NewGraphRAGRetriever(config)
	
	// 4. æ‰§è¡Œæ£€ç´¢
	docs, _ := retriever.Search(ctx, "Your query here")
	
	fmt.Printf("Found %d documents\n", len(docs))
}
```

### è¿è¡Œç¤ºä¾‹ç¨‹åº

```bash
# Clone ä»“åº“
git clone https://github.com/zhucl121/langchain-go
cd langchain-go

# è¿è¡Œ GraphRAG Demo
cd examples/graphrag_demo
go run main.go
```

---

## ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ

### GraphRAG æ¶æ„

GraphRAG ç»“åˆäº†ä¸¤ç§æ£€ç´¢æ–¹å¼ï¼š

1. **å‘é‡æ£€ç´¢** - åŸºäºè¯­ä¹‰ç›¸ä¼¼åº¦
2. **å›¾éå†** - åŸºäºç»“æ„åŒ–å…³ç³»

```
æŸ¥è¯¢ â†’ å‘é‡æ£€ç´¢ + å›¾éå† â†’ èåˆ â†’ é‡æ’åº â†’ ä¸Šä¸‹æ–‡å¢å¼º â†’ ç»“æœ
```

### ä¸»è¦ç»„ä»¶

#### 1. GraphDB - å›¾æ•°æ®åº“æŠ½è±¡

é€šç”¨çš„å›¾æ•°æ®åº“æ¥å£ï¼Œæ”¯æŒå¤šç§å®ç°ï¼š

- **Neo4j** - ç”Ÿäº§çº§å›¾æ•°æ®åº“ âœ…
- **Mock** - ç”¨äºæµ‹è¯• âœ…
- **NebulaGraph** - è®¡åˆ’ä¸­ â³

#### 2. KGBuilder - çŸ¥è¯†å›¾è°±æ„å»ºå™¨

è‡ªåŠ¨ä»æ–‡æœ¬æ„å»ºçŸ¥è¯†å›¾è°±ï¼š

- å®ä½“æå–ï¼ˆLLMé©±åŠ¨ï¼‰
- å…³ç³»æå–ï¼ˆLLMé©±åŠ¨ï¼‰
- å‘é‡åŒ–
- å­˜å‚¨åˆ°å›¾æ•°æ®åº“

#### 3. GraphRAGRetriever - æ··åˆæ£€ç´¢å™¨

ç»“åˆå‘é‡å’Œå›¾æ£€ç´¢ï¼š

- 4ç§èåˆç­–ç•¥
- 3ç§é‡æ’åºç­–ç•¥
- è‡ªåŠ¨ä¸Šä¸‹æ–‡å¢å¼º

---

## ğŸ—„ï¸ å›¾æ•°æ®åº“

### ä½¿ç”¨ Mock å›¾æ•°æ®åº“

é€‚åˆå¼€å‘å’Œæµ‹è¯•ï¼š

```go
import "github.com/zhucl121/langchain-go/retrieval/graphdb/mock"

graphDB := mock.NewMockGraphDB()
graphDB.Connect(ctx)
defer graphDB.Close()

// æ·»åŠ èŠ‚ç‚¹
node := &graphdb.Node{
    ID:    "node-1",
    Type:  "Person",
    Label: "John Smith",
    Properties: map[string]interface{}{
        "age": 35,
        "role": "CEO",
    },
}
graphDB.AddNode(ctx, node)

// æ·»åŠ è¾¹
edge := &graphdb.Edge{
    ID:       "edge-1",
    Source:   "node-1",
    Target:   "node-2",
    Type:     "WORKS_FOR",
    Directed: true,
}
graphDB.AddEdge(ctx, edge)

// æŸ¥è¯¢èŠ‚ç‚¹
node, _ := graphDB.GetNode(ctx, "node-1")
```

### ä½¿ç”¨ Neo4j

ç”Ÿäº§ç¯å¢ƒæ¨èï¼š

#### 1. å¯åŠ¨ Neo4j

```bash
docker compose -f docker-compose.graphdb.yml up -d neo4j
```

#### 2. åˆ›å»ºé©±åŠ¨å™¨

```go
import "github.com/zhucl121/langchain-go/retrieval/graphdb/neo4j"

config := neo4j.DefaultConfig()
config.URI = "bolt://localhost:7687"
config.Username = "neo4j"
config.Password = "your-password"

driver, _ := neo4j.NewNeo4jDriver(config)
driver.Connect(ctx)
defer driver.Close()
```

#### 3. å›¾éå†

```go
// BFS éå†
result, _ := driver.Traverse(ctx, "start-node-id", graphdb.TraverseOptions{
    MaxDepth:  3,
    Strategy:  graphdb.StrategyBFS,
    Direction: graphdb.DirectionBoth,
    Limit:     100,
})

fmt.Printf("Found %d nodes, %d edges\n", 
    len(result.Nodes), len(result.Edges))
```

#### 4. æœ€çŸ­è·¯å¾„

```go
path, _ := driver.ShortestPath(ctx, "node-a", "node-b", graphdb.PathOptions{
    MaxDepth:  5,
    Algorithm: graphdb.AlgorithmDijkstra,
})

fmt.Printf("Path length: %d\n", path.Length)
```

---

## ğŸ”¨ çŸ¥è¯†å›¾è°±æ„å»º

### åŸºç¡€ç”¨æ³•

```go
import "github.com/zhucl121/langchain-go/retrieval/graphdb/builder"

// 1. åˆ›å»ºå®ä½“æå–å™¨ï¼ˆä½¿ç”¨ LLMï¼‰
chatModel, _ := openai.New(openai.Config{APIKey: "sk-..."})
entityExtractor := builder.NewLLMEntityExtractor(chatModel, nil)

// 2. åˆ›å»ºå…³ç³»æå–å™¨
relationExtractor := builder.NewLLMRelationExtractor(chatModel, nil)

// 3. åˆ›å»ºåµŒå…¥å™¨
embeddings := embeddings.NewOpenAIEmbeddings(embeddings.OpenAIEmbeddingsConfig{
    APIKey: "sk-...",
    Model:  "text-embedding-3-small",
})
embedder := builder.NewEmbeddingModelAdapter(embeddings)

// 4. åˆ›å»º KG Builder
kgBuilder, _ := builder.NewKGBuilder(builder.KGBuilderConfig{
    GraphDB:           graphDB,
    EntityExtractor:   entityExtractor,
    RelationExtractor: relationExtractor,
    Embedder:          embedder,
    EnableEmbedding:   true,
})

// 5. æ„å»ºçŸ¥è¯†å›¾è°±
text := "John Smith is the CEO of TechCorp."
graph, _ := kgBuilder.Build(ctx, text)

fmt.Printf("Entities: %d, Relations: %d\n", 
    len(graph.Entities), len(graph.Relations))
```

### æ‰¹é‡æ„å»º

```go
texts := []string{
    "John Smith is the CEO of TechCorp.",
    "TechCorp is located in San Francisco.",
    "Alice works at TechCorp.",
}

// å¹¶å‘æ„å»º
graphs, _ := kgBuilder.BuildBatch(ctx, texts)

// åˆå¹¶å›¾
mergedGraph, _ := kgBuilder.Merge(ctx, graphs)
```

### ç›´æ¥å­˜å‚¨åˆ°å›¾æ•°æ®åº“

```go
_, _ = kgBuilder.BuildAndStore(ctx, text)
```

### ä½¿ç”¨ Schema

å®šä¹‰å®ä½“å’Œå…³ç³»çº¦æŸï¼š

```go
entitySchema := &builder.EntitySchema{
    Types: []string{"Person", "Organization", "Location"},
    RequiredProperties: []string{"name", "type"},
}

relationSchema := &builder.RelationSchema{
    AllowedTypes: []string{"WORKS_FOR", "LOCATED_IN"},
}

config := builder.KGBuilderConfig{
    // ... å…¶ä»–é…ç½®
    EntitySchemas:   []*builder.EntitySchema{entitySchema},
    RelationSchemas: []*builder.RelationSchema{relationSchema},
}
```

---

## ğŸ” GraphRAG æ£€ç´¢

### åŸºç¡€æ£€ç´¢

```go
import "github.com/zhucl121/langchain-go/retrieval/retrievers/graphrag"

// åˆ›å»ºæ£€ç´¢å™¨
config := graphrag.Config{
    GraphDB:      graphDB,
    VectorStore:  vectorStore,
    VectorWeight: 0.6,  // å‘é‡æƒé‡
    GraphWeight:  0.4,  // å›¾æƒé‡
    TopK:         10,
}

retriever, _ := graphrag.NewGraphRAGRetriever(config)

// æ‰§è¡Œæ£€ç´¢
docs, _ := retriever.Search(ctx, "Who is the CEO of TechCorp?")

for _, doc := range docs {
    fmt.Println(doc.Content)
    fmt.Println("Score:", doc.Metadata["fused_score"])
}
```

### èåˆç­–ç•¥

é€‰æ‹©ä¸åŒçš„èåˆç­–ç•¥ï¼š

```go
// Weighted - åŠ æƒèåˆï¼ˆé»˜è®¤ï¼‰
opts := graphrag.SearchOptions{
    FusionStrategy: graphrag.FusionStrategyWeighted,
    VectorWeight:   0.7,
    GraphWeight:    0.3,
}

// RRF - Reciprocal Rank Fusionï¼ˆæ¨èï¼‰
opts := graphrag.SearchOptions{
    FusionStrategy: graphrag.FusionStrategyRRF,
}

// Max - å–æœ€å¤§å€¼
opts := graphrag.SearchOptions{
    FusionStrategy: graphrag.FusionStrategyMax,
}

// Min - å–æœ€å°å€¼
opts := graphrag.SearchOptions{
    FusionStrategy: graphrag.FusionStrategyMin,
}

docs, _ := retriever.Search(ctx, query, opts)
```

### é‡æ’åºç­–ç•¥

```go
// Score - åˆ†æ•°æ’åºï¼ˆé»˜è®¤ï¼‰
opts := graphrag.SearchOptions{
    RerankStrategy: graphrag.RerankStrategyScore,
}

// Diversity - å¤šæ ·æ€§æ’åº
opts := graphrag.SearchOptions{
    RerankStrategy: graphrag.RerankStrategyDiversity,
}

// MMR - Maximal Marginal Relevance
opts := graphrag.SearchOptions{
    RerankStrategy: graphrag.RerankStrategyMMR,
    K:              20,  // è¿”å›20ä¸ªç»“æœ
}

docs, _ := retriever.Search(ctx, query, opts)
```

### æ£€ç´¢æ¨¡å¼

```go
// æ··åˆæ£€ç´¢ï¼ˆé»˜è®¤ï¼‰
opts := graphrag.SearchOptions{
    Mode: graphrag.SearchModeHybrid,
}

// ä»…å‘é‡æ£€ç´¢
opts := graphrag.SearchOptions{
    Mode: graphrag.SearchModeVector,
}

// ä»…å›¾æ£€ç´¢
opts := graphrag.SearchOptions{
    Mode: graphrag.SearchModeGraph,
}

docs, _ := retriever.Search(ctx, query, opts)
```

### ä¸Šä¸‹æ–‡å¢å¼º

```go
// å¯ç”¨ä¸Šä¸‹æ–‡å¢å¼ºï¼ˆé»˜è®¤ï¼‰
opts := graphrag.SearchOptions{
    EnableContextAugmentation: true,
}

docs, _ := retriever.Search(ctx, query, opts)

// æŸ¥çœ‹å¢å¼ºçš„å…ƒæ•°æ®
for _, doc := range docs {
    if entities, ok := doc.Metadata["related_entities"].([]string); ok {
        fmt.Println("Related entities:", entities)
    }
}
```

### æ€§èƒ½ç›‘æ§

```go
docs, _ := retriever.Search(ctx, query)

// è·å–ç»Ÿè®¡ä¿¡æ¯
stats := retriever.GetStatistics()

fmt.Printf("Vector results: %d\n", stats.VectorResultsCount)
fmt.Printf("Graph results: %d\n", stats.GraphResultsCount)
fmt.Printf("Fused results: %d\n", stats.FusedResultsCount)
fmt.Printf("Total time: %dms\n", stats.TotalTime)
```

---

## ğŸš€ è¿›é˜¶ä½¿ç”¨

### è‡ªå®šä¹‰å®ä½“æå–å™¨

```go
type MyEntityExtractor struct {
    // è‡ªå®šä¹‰å­—æ®µ
}

func (e *MyEntityExtractor) Extract(ctx context.Context, text string) ([]builder.Entity, error) {
    // è‡ªå®šä¹‰æå–é€»è¾‘
    entities := []builder.Entity{
        {ID: "custom-1", Name: "Custom Entity", Type: "Custom"},
    }
    return entities, nil
}

func (e *MyEntityExtractor) ExtractWithSchema(ctx context.Context, text string, schema *builder.EntitySchema) ([]builder.Entity, error) {
    // å¸¦ Schema çš„æå–
    return e.Extract(ctx, text)
}
```

### è‡ªå®šä¹‰è¯„åˆ†å‡½æ•°

```go
import "github.com/zhucl121/langchain-go/retrieval/retrievers/graphrag"

// è‡ªå®šä¹‰è¯„åˆ†å‡½æ•°
scorer := func(result graphrag.FusedResult) float64 {
    // è‡ªå®šä¹‰è¯„åˆ†é€»è¾‘
    score := result.FusedScore
    
    // æ ¹æ®å…ƒæ•°æ®è°ƒæ•´åˆ†æ•°
    if entities, ok := result.Document.Metadata["related_entities"].([]string); ok {
        score += float64(len(entities)) * 0.1
    }
    
    return score
}

// ä½¿ç”¨è‡ªå®šä¹‰è¯„åˆ†å™¨é‡æ’åº
rerankedResults := graphrag.RerankWithCustomScorer(fusedResults, scorer)
```

### å¢é‡æ›´æ–°

```go
// æ›´æ–°å·²æœ‰çš„çŸ¥è¯†å›¾è°±
newText := "Bob joined TechCorp as CTO."
_, _ = kgBuilder.UpdateIncremental(ctx, newText)
```

### å›¾éªŒè¯

```go
// å®ç° KGValidator æ¥å£
type MyValidator struct{}

func (v *MyValidator) Validate(ctx context.Context, graph *builder.KnowledgeGraph) error {
    // è‡ªå®šä¹‰éªŒè¯é€»è¾‘
    if len(graph.Entities) == 0 {
        return fmt.Errorf("graph has no entities")
    }
    return nil
}

// ä½¿ç”¨éªŒè¯å™¨
config := builder.KGBuilderConfig{
    // ... å…¶ä»–é…ç½®
    KGValidator:      &MyValidator{},
    EnableValidation: true,
}
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. æ‰¹é‡æ“ä½œ

```go
// æ‰¹é‡æ·»åŠ èŠ‚ç‚¹
nodes := []*graphdb.Node{/* ... */}
for _, node := range nodes {
    graphDB.AddNode(ctx, node)
}

// æ‰¹é‡æ„å»ºå›¾
texts := []string{/* ... */}
graphs, _ := kgBuilder.BuildBatch(ctx, texts)
```

### 2. è°ƒæ•´æƒé‡

```go
// å¦‚æœæ–‡æœ¬ç›¸ä¼¼åº¦æ›´é‡è¦
config.VectorWeight = 0.8
config.GraphWeight = 0.2

// å¦‚æœå›¾ç»“æ„æ›´é‡è¦
config.VectorWeight = 0.3
config.GraphWeight = 0.7
```

### 3. æ§åˆ¶éå†æ·±åº¦

```go
// å‡å°‘éå†æ·±åº¦ä»¥æé«˜é€Ÿåº¦
config.MaxTraverseDepth = 2  // æ¨èå€¼

// å¢åŠ æ·±åº¦ä»¥è·å–æ›´å¤šç›¸å…³ä¿¡æ¯
config.MaxTraverseDepth = 4
```

### 4. é€‰æ‹©é«˜æ•ˆçš„èåˆç­–ç•¥

```go
// RRF é€šå¸¸æ¯” Weighted æ›´å¿«
config.FusionStrategy = graphrag.FusionStrategyRRF
```

### 5. ç¼“å­˜ç­–ç•¥

```go
// ä½¿ç”¨å†…å­˜ç¼“å­˜å‘é‡
type CachedVectorStore struct {
    store vectorstores.VectorStore
    cache map[string][]float32
}

// å®ç°ç¼“å­˜é€»è¾‘...
```

---

## ğŸ› æ•…éšœæ’é™¤

### é—®é¢˜ 1: æ— æ³•è¿æ¥åˆ° Neo4j

**ç—‡çŠ¶**: `Failed to connect to Neo4j`

**è§£å†³æ–¹æ¡ˆ**:
```bash
# 1. æ£€æŸ¥ Neo4j æ˜¯å¦è¿è¡Œ
docker ps | grep neo4j

# 2. æ£€æŸ¥ç«¯å£æ˜¯å¦å¼€æ”¾
lsof -i :7687

# 3. æŸ¥çœ‹ Neo4j æ—¥å¿—
docker logs langchain-go-neo4j-1

# 4. é‡å¯ Neo4j
docker compose -f docker-compose.graphdb.yml restart neo4j
```

### é—®é¢˜ 2: å®ä½“æå–å¤±è´¥

**ç—‡çŠ¶**: `Entity extraction failed`

**è§£å†³æ–¹æ¡ˆ**:
```go
// 1. æ£€æŸ¥ API Key
fmt.Println("API Key:", os.Getenv("OPENAI_API_KEY"))

// 2. ä½¿ç”¨æ›´ç®€å•çš„æ–‡æœ¬æµ‹è¯•
text := "John works at Google."
entities, err := extractor.Extract(ctx, text)
if err != nil {
    log.Printf("Error: %v", err)
}

// 3. å¢åŠ è¶…æ—¶æ—¶é—´
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()
```

### é—®é¢˜ 3: æ£€ç´¢ç»“æœä¸ºç©º

**ç—‡çŠ¶**: `Search returns 0 results`

**è§£å†³æ–¹æ¡ˆ**:
```go
// 1. æ£€æŸ¥æ•°æ®æ˜¯å¦å·²æ·»åŠ 
stats := retriever.GetStatistics()
fmt.Printf("Vector: %d, Graph: %d\n", stats.VectorResultsCount, stats.GraphResultsCount)

// 2. é™ä½æœ€å°åˆ†æ•°é˜ˆå€¼
opts := graphrag.SearchOptions{
    MinScore: 0.0,  // ä¸è¿‡æ»¤
}

// 3. ä½¿ç”¨ä¸åŒçš„æ£€ç´¢æ¨¡å¼
opts := graphrag.SearchOptions{
    Mode: graphrag.SearchModeVector,  // ä»…å‘é‡
}
```

### é—®é¢˜ 4: æ€§èƒ½æ…¢

**ç—‡çŠ¶**: æ£€ç´¢æ—¶é—´è¿‡é•¿

**è§£å†³æ–¹æ¡ˆ**:
```go
// 1. å‡å°‘ TopK
config.TopK = 5

// 2. å‡å°‘éå†æ·±åº¦
config.MaxTraverseDepth = 1

// 3. ä½¿ç”¨æ›´å¿«çš„èåˆç­–ç•¥
config.FusionStrategy = graphrag.FusionStrategyMax

// 4. ç¦ç”¨ä¸Šä¸‹æ–‡å¢å¼º
opts := graphrag.SearchOptions{
    EnableContextAugmentation: false,
}
```

---

## â“ FAQ

### Q1: GraphRAG ä¸ä¼ ç»Ÿ RAG çš„åŒºåˆ«ï¼Ÿ

**A**: GraphRAG ç»“åˆäº†å‘é‡æ£€ç´¢å’Œå›¾éå†ï¼š

| ç‰¹æ€§ | ä¼ ç»Ÿ RAG | GraphRAG |
|------|---------|----------|
| æ£€ç´¢æ–¹å¼ | ä»…å‘é‡ | å‘é‡ + å›¾ |
| å…³ç³»ç†è§£ | âŒ | âœ… |
| ä¸Šä¸‹æ–‡ä¸°å¯Œåº¦ | â­â­â­ | â­â­â­â­â­ |
| é€‚ç”¨åœºæ™¯ | ä¸€èˆ¬æ–‡æ¡£ | å¤æ‚å…³ç³» |

### Q2: ä½•æ—¶ä½¿ç”¨ä¸åŒçš„èåˆç­–ç•¥ï¼Ÿ

**A**: 

- **Weighted**: é€šç”¨åœºæ™¯ï¼Œå¯è°ƒæƒé‡
- **RRF**: å¤šæ£€ç´¢å™¨ï¼Œå¯¹åˆ†æ•°scaleé²æ£’
- **Max**: ä»»ä¸€é«˜åˆ†éƒ½é‡è¦
- **Min**: ä¸¤è€…éƒ½è¦é«˜åˆ†

### Q3: å¦‚ä½•é€‰æ‹©å›¾æ•°æ®åº“ï¼Ÿ

**A**: 

- **Mock**: å¼€å‘/æµ‹è¯•
- **Neo4j**: ç”Ÿäº§ç¯å¢ƒï¼Œ<10äº¿èŠ‚ç‚¹
- **NebulaGraph**: ç”Ÿäº§ç¯å¢ƒï¼Œ>10äº¿èŠ‚ç‚¹ï¼ˆè®¡åˆ’ä¸­ï¼‰

### Q4: å®ä½“æå–çš„å‡†ç¡®ç‡å¦‚ä½•ï¼Ÿ

**A**: å–å†³äºä½¿ç”¨çš„ LLMï¼š

- GPT-4: 90-95%
- GPT-3.5: 80-85%
- å¯ä»¥é€šè¿‡ Schema çº¦æŸæé«˜å‡†ç¡®ç‡

### Q5: æ”¯æŒå“ªäº›è¯­è¨€ï¼Ÿ

**A**: æ”¯æŒæ‰€æœ‰ LLM æ”¯æŒçš„è¯­è¨€ï¼ŒåŒ…æ‹¬ï¼š

- è‹±è¯­ âœ…
- ä¸­æ–‡ âœ…
- æ—¥è¯­ âœ…
- å…¶ä»–è¯­è¨€ âœ…

### Q6: å¦‚ä½•é™ä½æˆæœ¬ï¼Ÿ

**A**: 

```go
// 1. ä½¿ç”¨æ›´ä¾¿å®œçš„æ¨¡å‹
config := openai.Config{
    Model: "gpt-3.5-turbo",  // æ¯” gpt-4 ä¾¿å®œ10å€
}

// 2. æ‰¹é‡å¤„ç†
texts := []string{/* ... */}
graphs, _ := kgBuilder.BuildBatch(ctx, texts)

// 3. ç¼“å­˜ç»“æœ
// å®ç°è‡ªå®šä¹‰ç¼“å­˜å±‚
```

### Q7: ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²å»ºè®®ï¼Ÿ

**A**: 

1. **ä½¿ç”¨ Neo4j** ä½œä¸ºå›¾æ•°æ®åº“
2. **é…ç½®è¿æ¥æ± **ï¼š`MaxConnectionPoolSize: 100`
3. **å¯ç”¨ç›‘æ§**ï¼šä½¿ç”¨ `GetStatistics()`
4. **è®¾ç½®è¶…æ—¶**ï¼š`ConnectionAcquisitionTimeout: 60s`
5. **ä½¿ç”¨ Docker Compose** éƒ¨ç½²

### Q8: å¦‚ä½•è´¡çŒ®ä»£ç ï¼Ÿ

**A**: 

```bash
# 1. Fork ä»“åº“
# 2. åˆ›å»ºåˆ†æ”¯
git checkout -b feature/my-feature

# 3. æäº¤æ›´æ”¹
git commit -m "feat: add my feature"

# 4. åˆ›å»º Pull Request
```

---

## ğŸ“š æ›´å¤šèµ„æº

### æ–‡æ¡£

- [å®ç°è®¡åˆ’](./V0.4.1_IMPLEMENTATION_PLAN.md)
- [Phase æŠ¥å‘Š](./V0.4.1_PHASE4_COMPLETE.md)
- [å®Œæ•´æ€»ç»“](./V0.4.1_SUMMARY.md)

### ç¤ºä¾‹

- [KG Builder Demo](../examples/kg_builder_demo/)
- [GraphRAG Demo](../examples/graphrag_demo/)

### API æ–‡æ¡£

- [GraphDB Package](../retrieval/graphdb/doc.go)
- [Builder Package](../retrieval/graphdb/builder/doc.go)
- [GraphRAG Package](../retrieval/retrievers/graphrag/doc.go)

---

**ç‰ˆæœ¬**: v0.4.1  
**æœ€åæ›´æ–°**: 2026-01-21  
**ä½œè€…**: LangChain-Go Team

éœ€è¦å¸®åŠ©ï¼Ÿ[æäº¤ Issue](https://github.com/zhucl121/langchain-go/issues)
