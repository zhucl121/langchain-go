# LangChain-Go v0.4.1 实施计划

**版本**: v0.4.1  
**创建日期**: 2026-01-20  
**基准版本**: v0.4.0 (已完成)  
**主题**: GraphRAG - 知识图谱增强检索

---

## 📊 执行摘要

v0.4.0 已成功交付可观测性系统，v0.4.1 将实现 **GraphRAG（Graph-based Retrieval Augmented Generation）**，将传统的向量检索与知识图谱相结合，为 RAG 应用提供更丰富的上下文和关系信息。

### 核心目标

1. **图数据库抽象**: 统一的图数据库接口
2. **Neo4j 集成**: 支持业界最成熟的图数据库
3. **知识图谱构建**: 自动从文档构建知识图谱
4. **图遍历检索**: 基于关系的检索能力
5. **混合检索**: 向量检索 + 图遍历的融合

---

## 🎯 技术架构

### 系统架构

```
┌─────────────────────────────────────────────────┐
│               User Query                         │
└───────────────┬─────────────────────────────────┘
                │
        ┌───────┴────────┐
        │   Query Parser  │ (提取实体、关系)
        └───────┬────────┘
                │
        ┌───────┴────────────────┐
        │                        │
        ▼                        ▼
  ┌─────────┐            ┌──────────────┐
  │ Vector  │            │    Graph     │
  │ Search  │            │  Traversal   │
  │ (相似度)│            │  (关系遍历)  │
  └────┬────┘            └──────┬───────┘
       │                        │
       │    ┌──────────┐        │
       └────►  Fusion  ◄────────┘
            │ Strategy │
            └─────┬────┘
                  │
                  ▼
          ┌───────────────┐
          │   Rerank &    │
          │   Augment     │
          └───────┬───────┘
                  │
                  ▼
          ┌───────────────┐
          │  LLM + RAG    │
          └───────────────┘
```

### 核心组件

1. **图数据库抽象层** (GraphDB Interface)
2. **Neo4j 驱动器** (Neo4j Driver)
3. **知识图谱构建器** (KG Builder)
4. **图遍历检索器** (Graph Traversal Retriever)
5. **混合检索器** (GraphRAG Retriever)
6. **实体识别** (Entity Recognition)
7. **关系抽取** (Relation Extraction)

---

## 📋 详细设计

### Phase 1: 图数据库抽象 (3-4 天)

#### 目标

定义统一的图数据库接口，支持多种图数据库实现。

#### 核心接口

```go
// retrieval/graphdb/interface.go

package graphdb

import "context"

// GraphDB 图数据库统一接口
type GraphDB interface {
    // 节点操作
    AddNode(ctx context.Context, node *Node) error
    GetNode(ctx context.Context, id string) (*Node, error)
    UpdateNode(ctx context.Context, node *Node) error
    DeleteNode(ctx context.Context, id string) error
    
    // 边操作
    AddEdge(ctx context.Context, edge *Edge) error
    GetEdge(ctx context.Context, id string) (*Edge, error)
    DeleteEdge(ctx context.Context, id string) error
    
    // 查询操作
    FindNodes(ctx context.Context, filter NodeFilter) ([]*Node, error)
    FindEdges(ctx context.Context, filter EdgeFilter) ([]*Edge, error)
    
    // 图遍历
    Traverse(ctx context.Context, startID string, opts TraverseOptions) (*TraverseResult, error)
    ShortestPath(ctx context.Context, startID, endID string, opts PathOptions) (*Path, error)
    
    // 批量操作
    BatchAddNodes(ctx context.Context, nodes []*Node) error
    BatchAddEdges(ctx context.Context, edges []*Edge) error
    
    // 连接管理
    Connect(ctx context.Context) error
    Close() error
    Ping(ctx context.Context) error
}

// Node 图节点
type Node struct {
    ID         string                 `json:"id"`
    Type       string                 `json:"type"`        // entity, concept, document
    Label      string                 `json:"label"`
    Properties map[string]interface{} `json:"properties"`
    Embedding  []float32              `json:"embedding,omitempty"`
    Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// Edge 图边
type Edge struct {
    ID         string                 `json:"id"`
    Source     string                 `json:"source"`
    Target     string                 `json:"target"`
    Type       string                 `json:"type"`        // relates_to, part_of, caused_by
    Label      string                 `json:"label"`
    Properties map[string]interface{} `json:"properties"`
    Weight     float64                `json:"weight,omitempty"`
}

// TraverseOptions 遍历选项
type TraverseOptions struct {
    MaxDepth      int      `json:"max_depth"`
    Direction     Direction `json:"direction"`    // outbound, inbound, both
    EdgeTypes     []string  `json:"edge_types"`   // 限制边类型
    NodeTypes     []string  `json:"node_types"`   // 限制节点类型
    Limit         int       `json:"limit"`
    IncludePath   bool      `json:"include_path"` // 是否返回路径
}

type Direction string

const (
    DirectionOutbound Direction = "outbound"
    DirectionInbound  Direction = "inbound"
    DirectionBoth     Direction = "both"
)

// TraverseResult 遍历结果
type TraverseResult struct {
    Nodes []*Node  `json:"nodes"`
    Edges []*Edge  `json:"edges"`
    Paths []*Path  `json:"paths,omitempty"`
}

// Path 路径
type Path struct {
    Nodes []*Node  `json:"nodes"`
    Edges []*Edge  `json:"edges"`
    Cost  float64  `json:"cost"`
}
```

#### 任务清单

- [ ] 定义 GraphDB 接口
- [ ] 定义 Node 和 Edge 数据结构
- [ ] 定义查询过滤器
- [ ] 定义遍历选项
- [ ] 编写单元测试
- [ ] 编写接口文档

#### 代码结构

```
retrieval/graphdb/
├── interface.go         # 核心接口定义
├── types.go            # 数据类型
├── filters.go          # 查询过滤器
├── options.go          # 选项模式
├── errors.go           # 错误定义
├── interface_test.go   # 接口测试
└── doc.go             # 包文档
```

---

### Phase 2: Neo4j 集成 (4-5 天)

#### 目标

实现 Neo4j 图数据库驱动器。

#### 核心实现

```go
// retrieval/graphdb/neo4j/driver.go

package neo4j

import (
    "context"
    "github.com/neo4j/neo4j-go-driver/v5/neo4j"
    "github.com/zhucl121/langchain-go/retrieval/graphdb"
)

// Neo4jConfig Neo4j 配置
type Neo4jConfig struct {
    URI      string
    Username string
    Password string
    Database string
}

// Neo4jDriver Neo4j 驱动器
type Neo4jDriver struct {
    config   Neo4jConfig
    driver   neo4j.DriverWithContext
    database string
}

// NewNeo4jDriver 创建 Neo4j 驱动器
func NewNeo4jDriver(config Neo4jConfig) (*Neo4jDriver, error) {
    driver, err := neo4j.NewDriverWithContext(
        config.URI,
        neo4j.BasicAuth(config.Username, config.Password, ""),
    )
    if err != nil {
        return nil, err
    }
    
    return &Neo4jDriver{
        config:   config,
        driver:   driver,
        database: config.Database,
    }, nil
}

// AddNode 添加节点
func (d *Neo4jDriver) AddNode(ctx context.Context, node *graphdb.Node) error {
    session := d.driver.NewSession(ctx, neo4j.SessionConfig{
        DatabaseName: d.database,
    })
    defer session.Close(ctx)
    
    query := `
        MERGE (n:` + node.Type + ` {id: $id})
        SET n += $properties
        SET n.label = $label
        RETURN n
    `
    
    params := map[string]interface{}{
        "id":         node.ID,
        "properties": node.Properties,
        "label":      node.Label,
    }
    
    _, err := session.Run(ctx, query, params)
    return err
}

// Traverse 图遍历
func (d *Neo4jDriver) Traverse(ctx context.Context, startID string, opts graphdb.TraverseOptions) (*graphdb.TraverseResult, error) {
    session := d.driver.NewSession(ctx, neo4j.SessionConfig{
        DatabaseName: d.database,
    })
    defer session.Close(ctx)
    
    // 构建 Cypher 查询
    query := d.buildTraverseQuery(startID, opts)
    
    result, err := session.Run(ctx, query, map[string]interface{}{
        "start_id":  startID,
        "max_depth": opts.MaxDepth,
    })
    if err != nil {
        return nil, err
    }
    
    return d.parseTraverseResult(result)
}

func (d *Neo4jDriver) buildTraverseQuery(startID string, opts graphdb.TraverseOptions) string {
    direction := "*"
    if opts.Direction == graphdb.DirectionOutbound {
        direction = "*>"
    } else if opts.Direction == graphdb.DirectionInbound {
        direction = "<*"
    }
    
    query := `
        MATCH path = (start {id: $start_id})-[r` + direction + ` *1..` + 
        fmt.Sprint(opts.MaxDepth) + `]-(end)
        RETURN path
    `
    
    if len(opts.NodeTypes) > 0 {
        query += ` WHERE any(n IN nodes(path) WHERE n:` + 
                 strings.Join(opts.NodeTypes, " OR n:") + `)`
    }
    
    if opts.Limit > 0 {
        query += fmt.Sprintf(` LIMIT %d`, opts.Limit)
    }
    
    return query
}
```

#### 任务清单

- [ ] 实现 Neo4j 驱动器
- [ ] 实现节点和边的 CRUD 操作
- [ ] 实现图遍历算法
- [ ] 实现最短路径算法
- [ ] 实现批量操作
- [ ] 实现连接池管理
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 编写使用文档

#### 代码结构

```
retrieval/graphdb/neo4j/
├── driver.go           # 驱动器实现
├── driver_test.go      # 单元测试
├── queries.go          # Cypher 查询构建
├── converter.go        # 数据转换
├── pool.go            # 连接池管理
├── integration_test.go # 集成测试
└── doc.go             # 包文档
```

---

### Phase 3: 知识图谱构建 (3-4 天)

#### 目标

从文档自动构建知识图谱。

#### 核心实现

```go
// retrieval/graphdb/builder/kg_builder.go

package builder

import (
    "context"
    "github.com/zhucl121/langchain-go/pkg/types"
    "github.com/zhucl121/langchain-go/retrieval/graphdb"
)

// KGBuilderConfig 知识图谱构建器配置
type KGBuilderConfig struct {
    GraphDB          graphdb.GraphDB
    EntityExtractor  EntityExtractor
    RelationExtractor RelationExtractor
    EmbeddingModel   types.Embedder
    ChunkSize        int
    ChunkOverlap     int
}

// KGBuilder 知识图谱构建器
type KGBuilder struct {
    config KGBuilderConfig
}

// BuildFromDocuments 从文档构建知识图谱
func (b *KGBuilder) BuildFromDocuments(ctx context.Context, docs []types.Document) error {
    for _, doc := range docs {
        // 1. 分块
        chunks := b.splitDocument(doc)
        
        // 2. 提取实体
        entities, err := b.extractEntities(ctx, chunks)
        if err != nil {
            return err
        }
        
        // 3. 提取关系
        relations, err := b.extractRelations(ctx, chunks, entities)
        if err != nil {
            return err
        }
        
        // 4. 生成向量
        entities, err = b.embedEntities(ctx, entities)
        if err != nil {
            return err
        }
        
        // 5. 存储到图数据库
        if err := b.storeToGraph(ctx, doc, entities, relations); err != nil {
            return err
        }
    }
    
    return nil
}

// EntityExtractor 实体提取器接口
type EntityExtractor interface {
    Extract(ctx context.Context, text string) ([]Entity, error)
}

// RelationExtractor 关系提取器接口
type RelationExtractor interface {
    Extract(ctx context.Context, text string, entities []Entity) ([]Relation, error)
}

// Entity 实体
type Entity struct {
    ID    string
    Type  string  // person, organization, location, concept
    Name  string
    Text  string
    Score float64
}

// Relation 关系
type Relation struct {
    ID     string
    Source string  // Entity ID
    Target string  // Entity ID
    Type   string  // works_for, located_in, related_to
    Score  float64
}

// LLMBasedEntityExtractor 基于 LLM 的实体提取器
type LLMBasedEntityExtractor struct {
    chatModel types.ChatModel
}

func (e *LLMBasedEntityExtractor) Extract(ctx context.Context, text string) ([]Entity, error) {
    prompt := `Extract all entities from the following text. 
    For each entity, provide: type (person/organization/location/concept), name, and text span.
    
    Text: ` + text
    
    messages := []types.Message{
        {Role: "user", Content: prompt},
    }
    
    result, err := e.chatModel.Invoke(ctx, messages)
    if err != nil {
        return nil, err
    }
    
    // 解析 LLM 输出
    return e.parseEntities(result.Content)
}
```

#### 任务清单

- [ ] 实现 KGBuilder 核心逻辑
- [ ] 实现基于 LLM 的实体提取
- [ ] 实现基于 LLM 的关系抽取
- [ ] 实现实体消歧
- [ ] 实现实体向量化
- [ ] 实现增量更新
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 编写使用文档

#### 代码结构

```
retrieval/graphdb/builder/
├── kg_builder.go       # 知识图谱构建器
├── kg_builder_test.go  # 单元测试
├── entity_extractor.go # 实体提取
├── relation_extractor.go # 关系抽取
├── llm_extractor.go    # 基于 LLM 的提取
├── embedder.go         # 向量化
├── utils.go            # 工具函数
└── doc.go              # 包文档
```

---

### Phase 4: GraphRAG 检索器 (4-5 天)

#### 目标

实现混合图向量检索器。

#### 核心实现

```go
// retrieval/retrievers/graphrag/retriever.go

package graphrag

import (
    "context"
    "github.com/zhucl121/langchain-go/pkg/types"
    "github.com/zhucl121/langchain-go/retrieval/graphdb"
    "github.com/zhucl121/langchain-go/retrieval/vectorstores"
)

// GraphRAGConfig 配置
type GraphRAGConfig struct {
    GraphDB          graphdb.GraphDB
    VectorStore      vectorstores.VectorStore
    GraphWeight      float64  // 图检索权重 (0-1)
    VectorWeight     float64  // 向量检索权重 (0-1)
    MaxTraverseDepth int      // 最大遍历深度
    TopK             int      // 返回 Top K 结果
}

// GraphRAGRetriever GraphRAG 检索器
type GraphRAGRetriever struct {
    config GraphRAGConfig
}

// NewGraphRAGRetriever 创建 GraphRAG 检索器
func NewGraphRAGRetriever(config GraphRAGConfig) *GraphRAGRetriever {
    return &GraphRAGRetriever{config: config}
}

// HybridSearch 混合检索
func (r *GraphRAGRetriever) HybridSearch(ctx context.Context, query string, k int) ([]types.Document, error) {
    // 1. 向量检索
    vectorDocs, err := r.vectorSearch(ctx, query, k)
    if err != nil {
        return nil, err
    }
    
    // 2. 提取查询实体
    queryEntities, err := r.extractQueryEntities(ctx, query)
    if err != nil {
        return nil, err
    }
    
    // 3. 图遍历检索
    graphNodes, err := r.graphTraverse(ctx, queryEntities)
    if err != nil {
        return nil, err
    }
    
    // 4. 融合结果
    fusedDocs := r.fuseResults(vectorDocs, graphNodes)
    
    // 5. 重排序
    rankedDocs := r.rerank(fusedDocs, query)
    
    // 6. 增强上下文
    augmentedDocs := r.augmentContext(rankedDocs, graphNodes)
    
    return augmentedDocs[:min(k, len(augmentedDocs))], nil
}

// vectorSearch 向量检索
func (r *GraphRAGRetriever) vectorSearch(ctx context.Context, query string, k int) ([]types.Document, error) {
    return r.config.VectorStore.SimilaritySearch(ctx, query, k)
}

// graphTraverse 图遍历
func (r *GraphRAGRetriever) graphTraverse(ctx context.Context, entities []string) ([]*graphdb.Node, error) {
    var allNodes []*graphdb.Node
    
    for _, entityID := range entities {
        result, err := r.config.GraphDB.Traverse(ctx, entityID, graphdb.TraverseOptions{
            MaxDepth:  r.config.MaxTraverseDepth,
            Direction: graphdb.DirectionBoth,
            Limit:     r.config.TopK,
        })
        if err != nil {
            continue
        }
        
        allNodes = append(allNodes, result.Nodes...)
    }
    
    return r.deduplicateNodes(allNodes), nil
}

// fuseResults 融合向量和图检索结果
func (r *GraphRAGRetriever) fuseResults(vectorDocs []types.Document, graphNodes []*graphdb.Node) []FusedResult {
    results := make([]FusedResult, 0)
    
    // 向量检索结果
    for i, doc := range vectorDocs {
        results = append(results, FusedResult{
            Document:    doc,
            VectorScore: 1.0 - float64(i)/float64(len(vectorDocs)),
            GraphScore:  0.0,
        })
    }
    
    // 图检索结果
    for _, node := range graphNodes {
        doc := r.nodeToDocument(node)
        found := false
        
        for i, result := range results {
            if result.Document.ID == doc.ID {
                results[i].GraphScore = 1.0
                found = true
                break
            }
        }
        
        if !found {
            results = append(results, FusedResult{
                Document:    doc,
                VectorScore: 0.0,
                GraphScore:  1.0,
            })
        }
    }
    
    // 计算融合分数
    for i := range results {
        results[i].FusedScore = r.config.VectorWeight*results[i].VectorScore +
            r.config.GraphWeight*results[i].GraphScore
    }
    
    return results
}

// augmentContext 增强上下文
func (r *GraphRAGRetriever) augmentContext(docs []types.Document, graphNodes []*graphdb.Node) []types.Document {
    for i, doc := range docs {
        // 查找文档相关的图节点
        relatedNodes := r.findRelatedNodes(doc, graphNodes)
        
        // 添加关系信息到 metadata
        if len(relatedNodes) > 0 {
            docs[i].Metadata["related_entities"] = r.extractEntityNames(relatedNodes)
            docs[i].Metadata["graph_context"] = r.buildGraphContext(relatedNodes)
        }
    }
    
    return docs
}

// FusedResult 融合结果
type FusedResult struct {
    Document    types.Document
    VectorScore float64
    GraphScore  float64
    FusedScore  float64
}
```

#### 任务清单

- [ ] 实现 GraphRAG 检索器
- [ ] 实现混合检索逻辑
- [ ] 实现融合策略
- [ ] 实现重排序算法
- [ ] 实现上下文增强
- [ ] 实现查询实体提取
- [ ] 编写单元测试
- [ ] 编写集成测试
- [ ] 编写性能测试
- [ ] 编写使用文档

#### 代码结构

```
retrieval/retrievers/graphrag/
├── retriever.go        # 检索器实现
├── retriever_test.go   # 单元测试
├── fusion.go           # 融合策略
├── reranker.go         # 重排序
├── augmenter.go        # 上下文增强
├── query_parser.go     # 查询解析
├── config.go           # 配置选项
└── doc.go              # 包文档
```

---

### Phase 5: 测试、优化和文档 (2-3 天)

#### 任务清单

**测试**:
- [ ] 单元测试覆盖率 > 85%
- [ ] 集成测试（Neo4j）
- [ ] 端到端测试
- [ ] 性能测试
- [ ] 压力测试

**优化**:
- [ ] 查询性能优化
- [ ] 批量操作优化
- [ ] 缓存策略
- [ ] 并发处理

**文档**:
- [ ] API 文档
- [ ] 用户指南
- [ ] 最佳实践
- [ ] 示例代码
- [ ] 架构设计文档

**示例**:
- [ ] 简单 GraphRAG 示例
- [ ] 知识图谱构建示例
- [ ] Neo4j 集成示例
- [ ] 完整应用示例

---

## 📊 交付清单

### 代码交付

| 模块 | 文件数 | 代码行数 | 测试行数 | 状态 |
|------|-------|---------|---------|------|
| 图数据库抽象 | 6 | 500 | 300 | ⏳ 待开始 |
| Neo4j 驱动器 | 6 | 800 | 500 | ⏳ 待开始 |
| 知识图谱构建 | 7 | 1,000 | 600 | ⏳ 待开始 |
| GraphRAG 检索器 | 7 | 1,200 | 700 | ⏳ 待开始 |
| 测试和文档 | - | - | - | ⏳ 待开始 |
| **总计** | **26** | **3,500** | **2,100** | **0%** |

### 文档交付

1. **V0.4.1_USER_GUIDE.md** - 完整用户指南
2. **GRAPHRAG_DESIGN.md** - 架构设计文档
3. **GRAPHRAG_BEST_PRACTICES.md** - 最佳实践
4. **NEO4J_INTEGRATION.md** - Neo4j 集成指南

### 示例交付

1. **simple_graphrag** - 简单示例
2. **kg_builder_demo** - 知识图谱构建
3. **neo4j_demo** - Neo4j 集成
4. **full_graphrag_app** - 完整应用

---

## 🚀 技术亮点

### 1. 灵活的图数据库抽象

支持多种图数据库实现：
- Neo4j (首选)
- ArangoDB (可选)
- 自定义实现

### 2. 智能实体识别

支持多种实体识别方式：
- 基于 LLM 的实体提取
- 基于规则的实体识别
- 混合方式

### 3. 高效图遍历

- 深度限制避免过度遍历
- 方向控制（出边/入边/双向）
- 类型过滤（节点类型、边类型）
- 路径记录

### 4. 智能融合策略

- 加权融合
- RRF 融合
- 自定义融合策略

### 5. 上下文增强

- 自动添加关系信息
- 构建子图上下文
- 提供推理路径

---

## 📅 时间线

### Week 1 (Day 1-5)
- Day 1-2: Phase 1 - 图数据库抽象
- Day 3-5: Phase 2 - Neo4j 集成（前3天）

### Week 2 (Day 6-10)
- Day 6-7: Phase 2 - Neo4j 集成（后2天）
- Day 8-10: Phase 3 - 知识图谱构建

### Week 3 (Day 11-15)
- Day 11-14: Phase 4 - GraphRAG 检索器
- Day 15: Phase 5 - 测试和优化（第1天）

### Week 4 (Day 16-18)
- Day 16-18: Phase 5 - 测试、优化、文档（2-3天）

**预计发布日期**: 2026-02-10

---

## 🎯 成功指标

### 功能指标
- [ ] 支持 Neo4j 图数据库
- [ ] 知识图谱自动构建
- [ ] 混合检索性能良好（< 200ms）
- [ ] 检索准确率提升 15%+
- [ ] 完整的测试覆盖

### 性能指标
- **图遍历**: < 50ms (深度 3)
- **混合检索**: < 200ms (Top 10)
- **知识图谱构建**: < 10s/文档
- **并发性能**: > 100 QPS

### 质量指标
- **测试覆盖率**: > 85%
- **代码质量**: A 级
- **文档完整度**: 100%

---

## 🔍 风险和挑战

### 1. Neo4j 学习曲线

**风险**: Cypher 查询语言学习成本

**缓解措施**:
- 提供完整示例
- 封装常用查询
- 详细文档

### 2. 图遍历性能

**风险**: 深度遍历可能较慢

**缓解措施**:
- 限制遍历深度
- 实现缓存策略
- 异步遍历

### 3. 知识图谱质量

**风险**: 自动构建准确率不足

**缓解措施**:
- 使用高质量 LLM
- 人工审核
- 持续优化

### 4. 融合策略优化

**风险**: 权重参数难以调优

**缓解措施**:
- 提供默认值
- 自适应调整
- A/B 测试

---

## 💡 未来扩展

### v0.4.1.1 (可选)
- 支持 ArangoDB
- 支持更多实体类型
- 支持更多关系类型

### v0.4.1.2 (可选)
- 图神经网络 (GNN)
- 知识图谱推理
- 图问答 (KGQA)

---

## 📚 参考资源

### 图数据库
- [Neo4j Documentation](https://neo4j.com/docs/)
- [Neo4j Go Driver](https://neo4j.com/docs/go-manual/current/)
- [Cypher Query Language](https://neo4j.com/docs/cypher-manual/current/)

### GraphRAG
- [Microsoft GraphRAG](https://github.com/microsoft/graphrag)
- [GraphRAG Research Paper](https://arxiv.org/abs/2404.16130)
- [Knowledge Graphs for RAG](https://arxiv.org/abs/2312.10997)

### 知识图谱
- [Knowledge Graph Construction](https://arxiv.org/abs/2203.08028)
- [Entity Recognition](https://arxiv.org/abs/2210.17413)
- [Relation Extraction](https://arxiv.org/abs/2204.12656)

---

## ✅ 下一步行动

### 立即开始 (2026-01-21)

1. **创建 v0.4.1 分支**
   ```bash
   git checkout -b feature/v0.4.1-graphrag
   ```

2. **设置 Neo4j 开发环境**
   ```bash
   docker run -d \
     --name neo4j \
     -p 7474:7474 -p 7687:7687 \
     -e NEO4J_AUTH=neo4j/password \
     neo4j:5.15
   ```

3. **开始 Phase 1: 图数据库抽象**
   - 创建 retrieval/graphdb/ 目录
   - 定义核心接口
   - 编写单元测试

---

**计划版本**: v0.4.1  
**创建日期**: 2026-01-20  
**作者**: LangChain-Go Team  
**状态**: ✅ **已批准，待执行**
