# LangChain-Go v0.4.2 å®æ–½è®¡åˆ’

**ç‰ˆæœ¬**: v0.4.2  
**åˆ›å»ºæ—¥æœŸ**: 2026-01-20  
**åŸºå‡†ç‰ˆæœ¬**: v0.4.1 (å¾…å®Œæˆ)  
**ä¸»é¢˜**: å­¦ä¹ å‹æ£€ç´¢ - è‡ªé€‚åº”ä¼˜åŒ–

---

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

v0.4.1 å°†å®Œæˆ GraphRAG åŠŸèƒ½ï¼Œv0.4.2 å°†å®ç°**å­¦ä¹ å‹æ£€ç´¢ï¼ˆLearning Retrievalï¼‰**ï¼Œé€šè¿‡æ”¶é›†ç”¨æˆ·åé¦ˆå’Œä½¿ç”¨æ•°æ®ï¼Œè‡ªåŠ¨ä¼˜åŒ–æ£€ç´¢ç­–ç•¥å’Œå‚æ•°ï¼ŒæŒç»­æå‡æ£€ç´¢è´¨é‡ã€‚

### æ ¸å¿ƒç›®æ ‡

1. **ç”¨æˆ·åé¦ˆæ”¶é›†**: æ˜¾å¼å’Œéšå¼åé¦ˆç³»ç»Ÿ
2. **æ£€ç´¢è´¨é‡è¯„ä¼°**: è‡ªåŠ¨åŒ–è¯„ä¼°æŒ‡æ ‡
3. **è‡ªé€‚åº”å‚æ•°è°ƒæ•´**: åŸºäºåé¦ˆä¼˜åŒ–å‚æ•°
4. **A/B æµ‹è¯•æ¡†æ¶**: å¯¹æ¯”ä¸åŒç­–ç•¥æ•ˆæœ
5. **æ£€ç´¢ç­–ç•¥ä¼˜åŒ–**: è‡ªåŠ¨é€‰æ‹©æœ€ä½³ç­–ç•¥

---

## ğŸ¯ æŠ€æœ¯æ¶æ„

### ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            User Query                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Query Router  â”‚ (é€‰æ‹©ç­–ç•¥)
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚            â”‚            â”‚
    â–¼            â–¼            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Strategyâ”‚  â”‚Strategyâ”‚  â”‚Strategyâ”‚
â”‚   A    â”‚  â”‚   B    â”‚  â”‚   C    â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
     â”‚           â”‚           â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Retrieve      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Feedback      â”‚
         â”‚  Collection    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Evaluation    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Optimization  â”‚
         â”‚  Engine        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Strategy      â”‚
         â”‚  Update        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒç»„ä»¶

1. **åé¦ˆæ”¶é›†å™¨** (Feedback Collector)
2. **è´¨é‡è¯„ä¼°å™¨** (Quality Evaluator)
3. **å‚æ•°ä¼˜åŒ–å™¨** (Parameter Optimizer)
4. **ç­–ç•¥è·¯ç”±å™¨** (Strategy Router)
5. **A/B æµ‹è¯•ç®¡ç†å™¨** (AB Test Manager)
6. **æ€§èƒ½ç›‘æ§å™¨** (Performance Monitor)
7. **ç­–ç•¥æ³¨å†Œè¡¨** (Strategy Registry)

---

## ğŸ“‹ è¯¦ç»†è®¾è®¡

### Phase 1: ç”¨æˆ·åé¦ˆæ”¶é›† (2-3 å¤©)

#### ç›®æ ‡

æ”¶é›†ç”¨æˆ·å¯¹æ£€ç´¢ç»“æœçš„æ˜¾å¼å’Œéšå¼åé¦ˆã€‚

#### æ ¸å¿ƒæ¥å£

```go
// retrieval/learning/feedback/collector.go

package feedback

import (
    "context"
    "time"
    "github.com/zhucl121/langchain-go/pkg/types"
)

// FeedbackCollector åé¦ˆæ”¶é›†å™¨
type FeedbackCollector interface {
    // è®°å½•æŸ¥è¯¢
    RecordQuery(ctx context.Context, query Query) error
    
    // è®°å½•æ£€ç´¢ç»“æœ
    RecordResults(ctx context.Context, queryID string, results []types.Document) error
    
    // æ”¶é›†æ˜¾å¼åé¦ˆ
    CollectExplicitFeedback(ctx context.Context, feedback ExplicitFeedback) error
    
    // æ”¶é›†éšå¼åé¦ˆ
    CollectImplicitFeedback(ctx context.Context, feedback ImplicitFeedback) error
    
    // è·å–æŸ¥è¯¢åé¦ˆ
    GetQueryFeedback(ctx context.Context, queryID string) (*QueryFeedback, error)
    
    // èšåˆåé¦ˆç»Ÿè®¡
    AggregateStats(ctx context.Context, opts AggregateOptions) (*FeedbackStats, error)
}

// Query æŸ¥è¯¢ä¿¡æ¯
type Query struct {
    ID        string    `json:"id"`
    Text      string    `json:"text"`
    UserID    string    `json:"user_id"`
    Strategy  string    `json:"strategy"`
    Timestamp time.Time `json:"timestamp"`
    Metadata  map[string]interface{} `json:"metadata"`
}

// ExplicitFeedback æ˜¾å¼åé¦ˆ
type ExplicitFeedback struct {
    QueryID   string    `json:"query_id"`
    UserID    string    `json:"user_id"`
    Type      FeedbackType `json:"type"`
    Rating    int       `json:"rating"`        // 1-5 æ˜Ÿ
    Comment   string    `json:"comment,omitempty"`
    Timestamp time.Time `json:"timestamp"`
}

type FeedbackType string

const (
    FeedbackTypePositive FeedbackType = "positive"   // ğŸ‘
    FeedbackTypeNegative FeedbackType = "negative"   // ğŸ‘
    FeedbackTypeRating   FeedbackType = "rating"     // â­
    FeedbackTypeComment  FeedbackType = "comment"    // ğŸ’¬
)

// ImplicitFeedback éšå¼åé¦ˆ
type ImplicitFeedback struct {
    QueryID    string    `json:"query_id"`
    UserID     string    `json:"user_id"`
    DocumentID string    `json:"document_id"`
    Action     UserAction `json:"action"`
    Duration   time.Duration `json:"duration"`
    Timestamp  time.Time `json:"timestamp"`
}

type UserAction string

const (
    ActionClick      UserAction = "click"        // ç‚¹å‡»
    ActionRead       UserAction = "read"         // é˜…è¯»
    ActionCopy       UserAction = "copy"         // å¤åˆ¶
    ActionDownload   UserAction = "download"     // ä¸‹è½½
    ActionIgnore     UserAction = "ignore"       // å¿½ç•¥
    ActionSkip       UserAction = "skip"         // è·³è¿‡
)

// QueryFeedback æŸ¥è¯¢åé¦ˆæ±‡æ€»
type QueryFeedback struct {
    Query            Query               `json:"query"`
    Results          []types.Document    `json:"results"`
    ExplicitFeedback []ExplicitFeedback  `json:"explicit_feedback"`
    ImplicitFeedback []ImplicitFeedback  `json:"implicit_feedback"`
    AvgRating        float64             `json:"avg_rating"`
    CTR              float64             `json:"ctr"`  // Click-Through Rate
    AvgReadDuration  time.Duration       `json:"avg_read_duration"`
}

// FeedbackStats åé¦ˆç»Ÿè®¡
type FeedbackStats struct {
    TotalQueries      int       `json:"total_queries"`
    AvgRating         float64   `json:"avg_rating"`
    PositiveRate      float64   `json:"positive_rate"`
    NegativeRate      float64   `json:"negative_rate"`
    AvgCTR            float64   `json:"avg_ctr"`
    AvgReadDuration   time.Duration `json:"avg_read_duration"`
    TopQueries        []string  `json:"top_queries"`
    LowRatingQueries  []string  `json:"low_rating_queries"`
}
```

#### å­˜å‚¨è®¾è®¡

```go
// feedback/storage.go

// FeedbackStorage åé¦ˆå­˜å‚¨æ¥å£
type FeedbackStorage interface {
    SaveQuery(ctx context.Context, query Query) error
    SaveResults(ctx context.Context, queryID string, results []types.Document) error
    SaveExplicitFeedback(ctx context.Context, feedback ExplicitFeedback) error
    SaveImplicitFeedback(ctx context.Context, feedback ImplicitFeedback) error
    
    GetQueryFeedback(ctx context.Context, queryID string) (*QueryFeedback, error)
    ListQueries(ctx context.Context, opts ListOptions) ([]Query, error)
    
    Aggregate(ctx context.Context, opts AggregateOptions) (*FeedbackStats, error)
}

// PostgreSQLStorage PostgreSQL å­˜å‚¨å®ç°
type PostgreSQLStorage struct {
    db *sql.DB
}

// SQL Schema
/*
CREATE TABLE queries (
    id VARCHAR(255) PRIMARY KEY,
    text TEXT NOT NULL,
    user_id VARCHAR(255),
    strategy VARCHAR(100),
    timestamp TIMESTAMP NOT NULL,
    metadata JSONB
);

CREATE TABLE retrieval_results (
    id SERIAL PRIMARY KEY,
    query_id VARCHAR(255) REFERENCES queries(id),
    document_id VARCHAR(255),
    rank INT,
    score FLOAT,
    document JSONB,
    timestamp TIMESTAMP NOT NULL
);

CREATE TABLE explicit_feedback (
    id SERIAL PRIMARY KEY,
    query_id VARCHAR(255) REFERENCES queries(id),
    user_id VARCHAR(255),
    type VARCHAR(50),
    rating INT,
    comment TEXT,
    timestamp TIMESTAMP NOT NULL
);

CREATE TABLE implicit_feedback (
    id SERIAL PRIMARY KEY,
    query_id VARCHAR(255) REFERENCES queries(id),
    user_id VARCHAR(255),
    document_id VARCHAR(255),
    action VARCHAR(50),
    duration_ms INT,
    timestamp TIMESTAMP NOT NULL
);

CREATE INDEX idx_queries_user ON queries(user_id);
CREATE INDEX idx_queries_timestamp ON queries(timestamp);
CREATE INDEX idx_feedback_query ON explicit_feedback(query_id);
CREATE INDEX idx_implicit_query ON implicit_feedback(query_id);
*/
```

#### ä»»åŠ¡æ¸…å•

- [ ] å®šä¹‰åé¦ˆæ”¶é›†æ¥å£
- [ ] å®ç° PostgreSQL å­˜å‚¨
- [ ] å®ç°æ˜¾å¼åé¦ˆæ”¶é›†
- [ ] å®ç°éšå¼åé¦ˆæ”¶é›†
- [ ] å®ç°åé¦ˆèšåˆç»Ÿè®¡
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™é›†æˆæµ‹è¯•
- [ ] ç¼–å†™ä½¿ç”¨æ–‡æ¡£

---

### Phase 2: æ£€ç´¢è´¨é‡è¯„ä¼° (2-3 å¤©)

#### ç›®æ ‡

è‡ªåŠ¨è¯„ä¼°æ£€ç´¢è´¨é‡ï¼Œæä¾›å¤šç»´åº¦æŒ‡æ ‡ã€‚

#### æ ¸å¿ƒå®ç°

```go
// retrieval/learning/evaluation/evaluator.go

package evaluation

import (
    "context"
    "github.com/zhucl121/langchain-go/pkg/types"
    "github.com/zhucl121/langchain-go/retrieval/learning/feedback"
)

// QualityEvaluator è´¨é‡è¯„ä¼°å™¨
type QualityEvaluator interface {
    // è¯„ä¼°å•ä¸ªæŸ¥è¯¢
    EvaluateQuery(ctx context.Context, queryFeedback *feedback.QueryFeedback) (*QueryMetrics, error)
    
    // è¯„ä¼°ç­–ç•¥
    EvaluateStrategy(ctx context.Context, strategyID string, opts EvaluateOptions) (*StrategyMetrics, error)
    
    // å¯¹æ¯”ç­–ç•¥
    CompareStrategies(ctx context.Context, strategyA, strategyB string) (*ComparisonResult, error)
}

// QueryMetrics æŸ¥è¯¢æŒ‡æ ‡
type QueryMetrics struct {
    QueryID string `json:"query_id"`
    
    // ç›¸å…³æ€§æŒ‡æ ‡
    Precision    float64 `json:"precision"`     // ç²¾ç¡®ç‡
    Recall       float64 `json:"recall"`        // å¬å›ç‡
    F1Score      float64 `json:"f1_score"`      // F1 åˆ†æ•°
    NDCG         float64 `json:"ndcg"`          // å½’ä¸€åŒ–æŠ˜æŸç´¯è®¡å¢ç›Š
    MRR          float64 `json:"mrr"`           // å¹³å‡å€’æ•°æ’å
    
    // ç”¨æˆ·æ»¡æ„åº¦æŒ‡æ ‡
    AvgRating    float64 `json:"avg_rating"`    // å¹³å‡è¯„åˆ†
    CTR          float64 `json:"ctr"`           // ç‚¹å‡»ç‡
    ReadRate     float64 `json:"read_rate"`     // é˜…è¯»ç‡
    
    // æ•ˆç‡æŒ‡æ ‡
    ResponseTime time.Duration `json:"response_time"` // å“åº”æ—¶é—´
    
    // ç»¼åˆå¾—åˆ†
    OverallScore float64 `json:"overall_score"` // ç»¼åˆå¾—åˆ† (0-1)
}

// StrategyMetrics ç­–ç•¥æŒ‡æ ‡
type StrategyMetrics struct {
    StrategyID   string        `json:"strategy_id"`
    TotalQueries int           `json:"total_queries"`
    AvgMetrics   QueryMetrics  `json:"avg_metrics"`
    P95Metrics   QueryMetrics  `json:"p95_metrics"`
    Timestamp    time.Time     `json:"timestamp"`
}

// ComparisonResult å¯¹æ¯”ç»“æœ
type ComparisonResult struct {
    StrategyA      StrategyMetrics `json:"strategy_a"`
    StrategyB      StrategyMetrics `json:"strategy_b"`
    Winner         string          `json:"winner"`
    Confidence     float64         `json:"confidence"`  // 0-1
    Improvement    float64         `json:"improvement"` // A vs B æå‡ç™¾åˆ†æ¯”
    SignificantAt  float64         `json:"significant_at"` // p-value
}

// DefaultEvaluator é»˜è®¤è¯„ä¼°å™¨å®ç°
type DefaultEvaluator struct {
    feedbackCollector feedback.FeedbackCollector
}

// EvaluateQuery è¯„ä¼°æŸ¥è¯¢
func (e *DefaultEvaluator) EvaluateQuery(ctx context.Context, queryFeedback *feedback.QueryFeedback) (*QueryMetrics, error) {
    metrics := &QueryMetrics{
        QueryID: queryFeedback.Query.ID,
    }
    
    // è®¡ç®—ç²¾ç¡®ç‡å’Œå¬å›ç‡
    relevantDocs := e.getRelevantDocuments(queryFeedback)
    retrievedDocs := queryFeedback.Results
    
    metrics.Precision = e.calculatePrecision(relevantDocs, retrievedDocs)
    metrics.Recall = e.calculateRecall(relevantDocs, retrievedDocs)
    metrics.F1Score = e.calculateF1(metrics.Precision, metrics.Recall)
    
    // è®¡ç®— NDCG
    metrics.NDCG = e.calculateNDCG(queryFeedback)
    
    // è®¡ç®— MRR
    metrics.MRR = e.calculateMRR(queryFeedback)
    
    // è®¡ç®—ç”¨æˆ·æ»¡æ„åº¦æŒ‡æ ‡
    metrics.AvgRating = queryFeedback.AvgRating
    metrics.CTR = queryFeedback.CTR
    metrics.ReadRate = e.calculateReadRate(queryFeedback)
    
    // è®¡ç®—ç»¼åˆå¾—åˆ†
    metrics.OverallScore = e.calculateOverallScore(metrics)
    
    return metrics, nil
}

// calculateNDCG è®¡ç®—å½’ä¸€åŒ–æŠ˜æŸç´¯è®¡å¢ç›Š
func (e *DefaultEvaluator) calculateNDCG(queryFeedback *feedback.QueryFeedback) float64 {
    // DCG@k = Î£ (rel_i / log2(i+1))
    dcg := 0.0
    for i, doc := range queryFeedback.Results {
        relevance := e.getRelevance(queryFeedback, doc.ID)
        dcg += relevance / math.Log2(float64(i+2))
    }
    
    // IDCG@k (ç†æƒ³æƒ…å†µ)
    relevances := e.getAllRelevances(queryFeedback)
    sort.Sort(sort.Reverse(sort.Float64Slice(relevances)))
    
    idcg := 0.0
    for i, rel := range relevances {
        if i >= len(queryFeedback.Results) {
            break
        }
        idcg += rel / math.Log2(float64(i+2))
    }
    
    if idcg == 0 {
        return 0
    }
    
    return dcg / idcg
}

// calculateMRR è®¡ç®—å¹³å‡å€’æ•°æ’å
func (e *DefaultEvaluator) calculateMRR(queryFeedback *feedback.QueryFeedback) float64 {
    for i, doc := range queryFeedback.Results {
        if e.isRelevant(queryFeedback, doc.ID) {
            return 1.0 / float64(i+1)
        }
    }
    return 0
}
```

#### ä»»åŠ¡æ¸…å•

- [ ] å®šä¹‰è¯„ä¼°æŒ‡æ ‡ä½“ç³»
- [ ] å®ç°ç²¾ç¡®ç‡/å¬å›ç‡è®¡ç®—
- [ ] å®ç° NDCG/MRR è®¡ç®—
- [ ] å®ç°ç”¨æˆ·æ»¡æ„åº¦æŒ‡æ ‡
- [ ] å®ç°ç­–ç•¥å¯¹æ¯”åˆ†æ
- [ ] å®ç°ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™æ–‡æ¡£

---

### Phase 3: è‡ªé€‚åº”å‚æ•°ä¼˜åŒ– (3-4 å¤©)

#### ç›®æ ‡

åŸºäºåé¦ˆå’Œè¯„ä¼°ç»“æœï¼Œè‡ªåŠ¨ä¼˜åŒ–æ£€ç´¢å‚æ•°ã€‚

#### æ ¸å¿ƒå®ç°

```go
// retrieval/learning/optimization/optimizer.go

package optimization

import (
    "context"
    "github.com/zhucl121/langchain-go/retrieval/learning/evaluation"
    "github.com/zhucl121/langchain-go/retrieval/learning/feedback"
)

// ParameterOptimizer å‚æ•°ä¼˜åŒ–å™¨
type ParameterOptimizer interface {
    // ä¼˜åŒ–å‚æ•°
    OptimizeParameters(ctx context.Context, strategyID string, opts OptimizeOptions) (*OptimizedParams, error)
    
    // å»ºè®®å‚æ•°
    SuggestParameters(ctx context.Context, queryPattern QueryPattern) (*SuggestedParams, error)
    
    // è‡ªåŠ¨è°ƒæ•´
    AutoTune(ctx context.Context, strategyID string) error
}

// OptimizedParams ä¼˜åŒ–åçš„å‚æ•°
type OptimizedParams struct {
    StrategyID string                 `json:"strategy_id"`
    Params     map[string]interface{} `json:"params"`
    
    // ä¼˜åŒ–ä¿¡æ¯
    PreviousScore float64 `json:"previous_score"`
    CurrentScore  float64 `json:"current_score"`
    Improvement   float64 `json:"improvement"`
    
    // ä¼˜åŒ–å†å²
    History []ParamChange `json:"history"`
}

// ParamChange å‚æ•°å˜åŒ–
type ParamChange struct {
    ParamName  string      `json:"param_name"`
    OldValue   interface{} `json:"old_value"`
    NewValue   interface{} `json:"new_value"`
    Reason     string      `json:"reason"`
    Timestamp  time.Time   `json:"timestamp"`
}

// BayesianOptimizer è´å¶æ–¯ä¼˜åŒ–å™¨
type BayesianOptimizer struct {
    evaluator         evaluation.QualityEvaluator
    feedbackCollector feedback.FeedbackCollector
    paramSpace        ParameterSpace
}

// ParameterSpace å‚æ•°ç©ºé—´å®šä¹‰
type ParameterSpace struct {
    Params []Parameter `json:"params"`
}

type Parameter struct {
    Name     string      `json:"name"`
    Type     ParamType   `json:"type"`
    Min      float64     `json:"min,omitempty"`
    Max      float64     `json:"max,omitempty"`
    Values   []string    `json:"values,omitempty"`
    Default  interface{} `json:"default"`
}

type ParamType string

const (
    ParamTypeInt    ParamType = "int"
    ParamTypeFloat  ParamType = "float"
    ParamTypeChoice ParamType = "choice"
)

// OptimizeParameters ä¼˜åŒ–å‚æ•°
func (o *BayesianOptimizer) OptimizeParameters(ctx context.Context, strategyID string, opts OptimizeOptions) (*OptimizedParams, error) {
    // 1. è·å–å½“å‰å‚æ•°å’Œæ€§èƒ½
    currentParams := o.getCurrentParams(strategyID)
    currentScore := o.getCurrentScore(ctx, strategyID)
    
    // 2. ä½¿ç”¨è´å¶æ–¯ä¼˜åŒ–æœç´¢å‚æ•°ç©ºé—´
    bestParams, bestScore := o.bayesianSearch(ctx, strategyID, opts)
    
    // 3. éªŒè¯æ–°å‚æ•°
    if bestScore <= currentScore {
        return &OptimizedParams{
            StrategyID:    strategyID,
            Params:        currentParams,
            PreviousScore: currentScore,
            CurrentScore:  currentScore,
            Improvement:   0,
        }, nil
    }
    
    // 4. åº”ç”¨æ–°å‚æ•°
    history := []ParamChange{}
    for key, newValue := range bestParams {
        if oldValue, ok := currentParams[key]; ok && oldValue != newValue {
            history = append(history, ParamChange{
                ParamName: key,
                OldValue:  oldValue,
                NewValue:  newValue,
                Reason:    "Bayesian optimization",
                Timestamp: time.Now(),
            })
        }
    }
    
    return &OptimizedParams{
        StrategyID:    strategyID,
        Params:        bestParams,
        PreviousScore: currentScore,
        CurrentScore:  bestScore,
        Improvement:   (bestScore - currentScore) / currentScore * 100,
        History:       history,
    }, nil
}

// bayesianSearch è´å¶æ–¯æœç´¢
func (o *BayesianOptimizer) bayesianSearch(ctx context.Context, strategyID string, opts OptimizeOptions) (map[string]interface{}, float64) {
    // é«˜æ–¯è¿‡ç¨‹å›å½’
    gp := o.initGaussianProcess()
    
    bestParams := make(map[string]interface{})
    bestScore := 0.0
    
    for i := 0; i < opts.MaxIterations; i++ {
        // ä½¿ç”¨é‡‡é›†å‡½æ•°é€‰æ‹©ä¸‹ä¸€ä¸ªå‚æ•°ç‚¹
        nextParams := o.acquisitionFunction(gp, opts.AcquisitionType)
        
        // è¯„ä¼°å‚æ•°
        score := o.evaluateParams(ctx, strategyID, nextParams)
        
        // æ›´æ–°é«˜æ–¯è¿‡ç¨‹
        gp.Update(nextParams, score)
        
        if score > bestScore {
            bestScore = score
            bestParams = nextParams
        }
    }
    
    return bestParams, bestScore
}

// AutoTune è‡ªåŠ¨è°ƒä¼˜
func (o *BayesianOptimizer) AutoTune(ctx context.Context, strategyID string) error {
    // æŒç»­ç›‘æ§å’Œä¼˜åŒ–
    ticker := time.NewTicker(1 * time.Hour)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            // æ£€æŸ¥æ€§èƒ½
            metrics, err := o.evaluator.EvaluateStrategy(ctx, strategyID, evaluation.EvaluateOptions{
                TimeRange: time.Hour * 24,
            })
            if err != nil {
                continue
            }
            
            // å¦‚æœæ€§èƒ½ä¸‹é™ï¼Œè§¦å‘ä¼˜åŒ–
            if metrics.AvgMetrics.OverallScore < 0.7 {
                optimized, err := o.OptimizeParameters(ctx, strategyID, OptimizeOptions{
                    MaxIterations: 50,
                })
                if err != nil {
                    continue
                }
                
                // åº”ç”¨ä¼˜åŒ–åçš„å‚æ•°
                o.applyParams(strategyID, optimized.Params)
            }
        }
    }
}
```

#### ä»»åŠ¡æ¸…å•

- [ ] å®šä¹‰å‚æ•°ç©ºé—´
- [ ] å®ç°è´å¶æ–¯ä¼˜åŒ–
- [ ] å®ç°å‚æ•°éªŒè¯
- [ ] å®ç°è‡ªåŠ¨è°ƒä¼˜
- [ ] å®ç°å‚æ•°å›æ»š
- [ ] å®ç°å‚æ•°å†å²è®°å½•
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™æ–‡æ¡£

---

### Phase 4: A/B æµ‹è¯•æ¡†æ¶ (3-4 å¤©)

#### ç›®æ ‡

å¯¹æ¯”ä¸åŒæ£€ç´¢ç­–ç•¥çš„æ•ˆæœã€‚

#### æ ¸å¿ƒå®ç°

```go
// retrieval/learning/abtest/manager.go

package abtest

import (
    "context"
    "hash/fnv"
)

// ABTestManager A/B æµ‹è¯•ç®¡ç†å™¨
type ABTestManager interface {
    // åˆ›å»ºå®éªŒ
    CreateExperiment(ctx context.Context, exp Experiment) error
    
    // åˆ†æµç”¨æˆ·
    AssignVariant(ctx context.Context, userID string, experimentID string) (string, error)
    
    // è®°å½•ç»“æœ
    RecordResult(ctx context.Context, result ExperimentResult) error
    
    // åˆ†æç»“æœ
    AnalyzeExperiment(ctx context.Context, experimentID string) (*ExperimentAnalysis, error)
    
    // ç»“æŸå®éªŒ
    EndExperiment(ctx context.Context, experimentID string, winner string) error
}

// Experiment A/B æµ‹è¯•å®éªŒ
type Experiment struct {
    ID          string                 `json:"id"`
    Name        string                 `json:"name"`
    Description string                 `json:"description"`
    Variants    []Variant              `json:"variants"`
    StartTime   time.Time              `json:"start_time"`
    EndTime     time.Time              `json:"end_time,omitempty"`
    Status      ExperimentStatus       `json:"status"`
    Traffic     float64                `json:"traffic"`  // 0-1, å‚ä¸å®éªŒçš„æµé‡æ¯”ä¾‹
    Metadata    map[string]interface{} `json:"metadata"`
}

// Variant å®éªŒå˜ä½“
type Variant struct {
    ID       string                 `json:"id"`
    Name     string                 `json:"name"`
    Strategy string                 `json:"strategy"`  // æ£€ç´¢ç­–ç•¥ ID
    Params   map[string]interface{} `json:"params"`
    Weight   float64                `json:"weight"`    // æµé‡æƒé‡
}

type ExperimentStatus string

const (
    StatusDraft   ExperimentStatus = "draft"
    StatusRunning ExperimentStatus = "running"
    StatusPaused  ExperimentStatus = "paused"
    StatusEnded   ExperimentStatus = "ended"
)

// ExperimentResult å®éªŒç»“æœ
type ExperimentResult struct {
    ExperimentID string                 `json:"experiment_id"`
    VariantID    string                 `json:"variant_id"`
    UserID       string                 `json:"user_id"`
    QueryID      string                 `json:"query_id"`
    Metrics      evaluation.QueryMetrics `json:"metrics"`
    Timestamp    time.Time              `json:"timestamp"`
}

// ExperimentAnalysis å®éªŒåˆ†æ
type ExperimentAnalysis struct {
    ExperimentID string                    `json:"experiment_id"`
    Variants     map[string]VariantMetrics `json:"variants"`
    Winner       string                    `json:"winner,omitempty"`
    Confidence   float64                   `json:"confidence"`
    Completed    bool                      `json:"completed"`
}

// VariantMetrics å˜ä½“æŒ‡æ ‡
type VariantMetrics struct {
    VariantID    string  `json:"variant_id"`
    SampleSize   int     `json:"sample_size"`
    AvgScore     float64 `json:"avg_score"`
    StdDev       float64 `json:"std_dev"`
    ConfInterval [2]float64 `json:"conf_interval"` // 95% ç½®ä¿¡åŒºé—´
}

// DefaultABTestManager é»˜è®¤å®ç°
type DefaultABTestManager struct {
    storage ABTestStorage
}

// AssignVariant åˆ†æµç”¨æˆ·
func (m *DefaultABTestManager) AssignVariant(ctx context.Context, userID string, experimentID string) (string, error) {
    exp, err := m.storage.GetExperiment(ctx, experimentID)
    if err != nil {
        return "", err
    }
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²åˆ†é…
    if assignment, err := m.storage.GetAssignment(ctx, experimentID, userID); err == nil {
        return assignment.VariantID, nil
    }
    
    // å“ˆå¸Œåˆ†æµ
    hash := m.hashUserID(userID)
    bucketSize := 1.0 / float64(len(exp.Variants))
    
    cumulative := 0.0
    for _, variant := range exp.Variants {
        cumulative += variant.Weight
        if hash < cumulative {
            // ä¿å­˜åˆ†é…
            m.storage.SaveAssignment(ctx, Assignment{
                ExperimentID: experimentID,
                UserID:       userID,
                VariantID:    variant.ID,
                Timestamp:    time.Now(),
            })
            return variant.ID, nil
        }
    }
    
    return exp.Variants[0].ID, nil
}

func (m *DefaultABTestManager) hashUserID(userID string) float64 {
    h := fnv.New64a()
    h.Write([]byte(userID))
    return float64(h.Sum64()) / float64(^uint64(0))
}

// AnalyzeExperiment åˆ†æå®éªŒ
func (m *DefaultABTestManager) AnalyzeExperiment(ctx context.Context, experimentID string) (*ExperimentAnalysis, error) {
    results, err := m.storage.GetResults(ctx, experimentID)
    if err != nil {
        return nil, err
    }
    
    analysis := &ExperimentAnalysis{
        ExperimentID: experimentID,
        Variants:     make(map[string]VariantMetrics),
    }
    
    // æŒ‰å˜ä½“èšåˆç»“æœ
    variantScores := make(map[string][]float64)
    for _, result := range results {
        variantScores[result.VariantID] = append(
            variantScores[result.VariantID],
            result.Metrics.OverallScore,
        )
    }
    
    // è®¡ç®—æ¯ä¸ªå˜ä½“çš„æŒ‡æ ‡
    for variantID, scores := range variantScores {
        analysis.Variants[variantID] = VariantMetrics{
            VariantID:    variantID,
            SampleSize:   len(scores),
            AvgScore:     mean(scores),
            StdDev:       stdDev(scores),
            ConfInterval: confidenceInterval(scores, 0.95),
        }
    }
    
    // ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ (t-test)
    if len(analysis.Variants) == 2 {
        winner, confidence := m.tTest(variantScores)
        analysis.Winner = winner
        analysis.Confidence = confidence
        analysis.Completed = confidence > 0.95
    }
    
    return analysis, nil
}
```

#### ä»»åŠ¡æ¸…å•

- [ ] å®ç°å®éªŒç®¡ç†
- [ ] å®ç°ç”¨æˆ·åˆ†æµ
- [ ] å®ç°ç»“æœè®°å½•
- [ ] å®ç°ç»Ÿè®¡åˆ†æ
- [ ] å®ç° t-test
- [ ] å®ç°å¯è§†åŒ–æŠ¥å‘Š
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™æ–‡æ¡£

---

### Phase 5: æµ‹è¯•ã€ä¼˜åŒ–å’Œæ–‡æ¡£ (2-3 å¤©)

#### ä»»åŠ¡æ¸…å•

**æµ‹è¯•**:
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 85%
- [ ] é›†æˆæµ‹è¯•
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•

**ä¼˜åŒ–**:
- [ ] åé¦ˆæ”¶é›†æ€§èƒ½ä¼˜åŒ–
- [ ] è¯„ä¼°è®¡ç®—ä¼˜åŒ–
- [ ] å‚æ•°ä¼˜åŒ–æ€§èƒ½
- [ ] ç¼“å­˜ç­–ç•¥

**æ–‡æ¡£**:
- [ ] API æ–‡æ¡£
- [ ] ç”¨æˆ·æŒ‡å—
- [ ] æœ€ä½³å®è·µ
- [ ] ç¤ºä¾‹ä»£ç 

---

## ğŸ“Š äº¤ä»˜æ¸…å•

### ä»£ç äº¤ä»˜

| æ¨¡å— | æ–‡ä»¶æ•° | ä»£ç è¡Œæ•° | æµ‹è¯•è¡Œæ•° | çŠ¶æ€ |
|------|-------|---------|---------|------|
| åé¦ˆæ”¶é›† | 5 | 600 | 400 | â³ å¾…å¼€å§‹ |
| è´¨é‡è¯„ä¼° | 4 | 500 | 300 | â³ å¾…å¼€å§‹ |
| å‚æ•°ä¼˜åŒ– | 5 | 700 | 400 | â³ å¾…å¼€å§‹ |
| A/B æµ‹è¯• | 5 | 600 | 400 | â³ å¾…å¼€å§‹ |
| **æ€»è®¡** | **19** | **2,400** | **1,500** | **0%** |

### æ–‡æ¡£äº¤ä»˜

1. **V0.4.2_USER_GUIDE.md** - ç”¨æˆ·æŒ‡å—
2. **LEARNING_RETRIEVAL_DESIGN.md** - æ¶æ„è®¾è®¡
3. **AB_TEST_GUIDE.md** - A/B æµ‹è¯•æŒ‡å—
4. **OPTIMIZATION_BEST_PRACTICES.md** - ä¼˜åŒ–æœ€ä½³å®è·µ

---

## ğŸ“… æ—¶é—´çº¿

**Week 1** (Day 1-5): Phase 1-2  
**Week 2** (Day 6-10): Phase 3-4  
**Week 3** (Day 11-15): Phase 5

**é¢„è®¡å‘å¸ƒæ—¥æœŸ**: 2026-03-05

---

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

- [ ] è‡ªåŠ¨æ”¶é›†ç”¨æˆ·åé¦ˆ
- [ ] æ£€ç´¢è´¨é‡æŒç»­æå‡
- [ ] A/B æµ‹è¯•æ¡†æ¶å¯ç”¨
- [ ] ä¼˜åŒ–æ•ˆæœå¯é‡åŒ–
- [ ] æ”¯æŒå¤šç§ä¼˜åŒ–ç­–ç•¥

---

**è®¡åˆ’ç‰ˆæœ¬**: v0.4.2  
**åˆ›å»ºæ—¥æœŸ**: 2026-01-20  
**ä½œè€…**: LangChain-Go Team  
**çŠ¶æ€**: âœ… **å·²æ‰¹å‡†ï¼Œå¾…æ‰§è¡Œ**
