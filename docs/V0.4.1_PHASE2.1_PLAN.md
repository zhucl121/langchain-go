# v0.4.1 Phase 2.1: NebulaGraph é›†æˆå®ç°è®¡åˆ’

**ç›®æ ‡**: å®ç° NebulaGraph å›¾æ•°æ®åº“é©±åŠ¨å™¨ï¼Œæ‰©å±•å¤šå›¾æ•°æ®åº“æ”¯æŒ

**å·¥ä½œé‡**: 4-5å¤©  
**ä¼˜å…ˆçº§**: é«˜  
**çŠ¶æ€**: ğŸš§ è¿›è¡Œä¸­  

---

## ğŸ“‹ èƒŒæ™¯

NebulaGraph æ˜¯ä¸€ä¸ªå¼€æºçš„åˆ†å¸ƒå¼å›¾æ•°æ®åº“ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- âœ… åˆ†å¸ƒå¼æ¶æ„ï¼Œçº¿æ€§æ‰©å±•
- âœ… é«˜æ€§èƒ½ï¼ˆç™¾ä¸‡ QPSï¼‰
- âœ… æ”¯æŒè¶…å¤§è§„æ¨¡å›¾ï¼ˆåƒäº¿çº§èŠ‚ç‚¹/è¾¹ï¼‰
- âœ… nGQL æŸ¥è¯¢è¯­è¨€ï¼ˆç±»ä¼¼ Cypherï¼‰
- âœ… åŸç”Ÿæ”¯æŒå±æ€§å›¾æ¨¡å‹

### vs Neo4j

| ç‰¹æ€§ | Neo4j | NebulaGraph |
|------|-------|-------------|
| æ¶æ„ | å•æœº/é›†ç¾¤ | åˆ†å¸ƒå¼åŸç”Ÿ |
| æ‰©å±•æ€§ | å‚ç›´ä¸ºä¸» | æ°´å¹³æ‰©å±• |
| èŠ‚ç‚¹è§„æ¨¡ | <10äº¿ | >10äº¿ |
| æŸ¥è¯¢è¯­è¨€ | Cypher | nGQL |
| éƒ¨ç½²å¤æ‚åº¦ | ä½ | ä¸­ç­‰ |
| é€‚ç”¨åœºæ™¯ | ä¸­å°è§„æ¨¡ | å¤§è§„æ¨¡ |

---

## ğŸ¯ ç›®æ ‡

### æ ¸å¿ƒç›®æ ‡

1. âœ… å®ç° NebulaGraph é©±åŠ¨å™¨
2. âœ… å®ç° nGQL æŸ¥è¯¢æ„å»ºå™¨
3. âœ… æ”¯æŒæ‰€æœ‰ GraphDB æ¥å£æ“ä½œ
4. âœ… é›†æˆæµ‹è¯•
5. âœ… Docker Compose é…ç½®
6. âœ… ç¤ºä¾‹ç¨‹åº

### éç›®æ ‡

- âŒ ä¸å®ç°åˆ†å¸ƒå¼éƒ¨ç½²ï¼ˆä½¿ç”¨å•æœºæ¨¡å¼ï¼‰
- âŒ ä¸å®ç°æ‰€æœ‰ nGQL ç‰¹æ€§ï¼ˆä»…æ ¸å¿ƒåŠŸèƒ½ï¼‰
- âŒ ä¸å®ç°æ€§èƒ½è°ƒä¼˜ï¼ˆä½¿ç”¨é»˜è®¤é…ç½®ï¼‰

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### ç›®å½•ç»“æ„

```
retrieval/graphdb/nebula/
â”œâ”€â”€ driver.go           # NebulaGraph é©±åŠ¨å™¨
â”œâ”€â”€ config.go           # é…ç½®ç®¡ç†
â”œâ”€â”€ queries.go          # nGQL æŸ¥è¯¢æ„å»ºå™¨
â”œâ”€â”€ converter.go        # ç±»å‹è½¬æ¢å™¨
â”œâ”€â”€ connection.go       # è¿æ¥ç®¡ç†
â”œâ”€â”€ operations.go       # åŸºç¡€æ“ä½œ
â”œâ”€â”€ traverse.go         # éå†æ“ä½œ
â”œâ”€â”€ path.go            # è·¯å¾„æŸ¥è¯¢
â”œâ”€â”€ doc.go             # åŒ…æ–‡æ¡£
â”œâ”€â”€ driver_test.go     # å•å…ƒæµ‹è¯•
â””â”€â”€ integration_test.go # é›†æˆæµ‹è¯•
```

### æ ¸å¿ƒç»„ä»¶

#### 1. NebulaDriver

```go
type NebulaDriver struct {
    config    Config
    pool      *nebula.ConnectionPool
    spaceName string
    mu        sync.RWMutex
    connected bool
}
```

#### 2. nGQL æŸ¥è¯¢æ„å»ºå™¨

```go
// èŠ‚ç‚¹æ“ä½œ
INSERT VERTEX Person(name, age) VALUES "person-1":("John", 30);
FETCH PROP ON Person "person-1";
UPDATE VERTEX "person-1" SET Person.age = 31;
DELETE VERTEX "person-1";

// è¾¹æ“ä½œ
INSERT EDGE WORKS_FOR(since) VALUES "person-1"->"org-1":(2020);
FETCH PROP ON WORKS_FOR "person-1"->"org-1";
DELETE EDGE WORKS_FOR "person-1"->"org-1";

// éå†
GO FROM "person-1" OVER WORKS_FOR YIELD dst(edge);
GO 1 TO 3 STEPS FROM "person-1" OVER * YIELD dst(edge);

// è·¯å¾„æŸ¥è¯¢
FIND SHORTEST PATH FROM "person-1" TO "org-1" OVER *;
```

---

## ğŸ“ è¯¦ç»†å®ç°

### Phase 2.1.1: åŸºç¡€é©±åŠ¨å™¨ (1å¤©)

**æ–‡ä»¶**: `driver.go`, `config.go`, `connection.go`

#### driver.go

```go
package nebula

import (
    "context"
    "fmt"
    "sync"
    
    nebula "github.com/vesoft-inc/nebula-go/v3"
    "github.com/zhucl121/langchain-go/retrieval/graphdb"
)

// NebulaDriver NebulaGraph é©±åŠ¨å™¨
type NebulaDriver struct {
    config    Config
    pool      *nebula.ConnectionPool
    session   *nebula.Session
    spaceName string
    mu        sync.RWMutex
    connected bool
}

// NewNebulaDriver åˆ›å»º NebulaGraph é©±åŠ¨å™¨
func NewNebulaDriver(config Config) (*NebulaDriver, error) {
    if err := config.Validate(); err != nil {
        return nil, err
    }
    
    return &NebulaDriver{
        config:    config,
        spaceName: config.Space,
    }, nil
}

// Connect è¿æ¥åˆ° NebulaGraph
func (d *NebulaDriver) Connect(ctx context.Context) error {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    if d.connected {
        return nil
    }
    
    // åˆ›å»ºè¿æ¥æ± 
    pool, err := nebula.NewConnectionPool(
        d.config.Addresses,
        nebula.PoolConfig{
            TimeOut:         d.config.Timeout,
            IdleTime:        d.config.IdleTime,
            MaxConnPoolSize: d.config.MaxConnPoolSize,
            MinConnPoolSize: d.config.MinConnPoolSize,
        },
        nebula.DefaultLogger{},
    )
    if err != nil {
        return fmt.Errorf("failed to create connection pool: %w", err)
    }
    
    d.pool = pool
    
    // åˆ›å»º session
    session, err := d.pool.GetSession(d.config.Username, d.config.Password)
    if err != nil {
        return fmt.Errorf("failed to create session: %w", err)
    }
    
    d.session = session
    
    // ä½¿ç”¨ space
    if d.spaceName != "" {
        _, err = d.session.Execute(fmt.Sprintf("USE %s", d.spaceName))
        if err != nil {
            return fmt.Errorf("failed to use space: %w", err)
        }
    }
    
    d.connected = true
    return nil
}

// Close å…³é—­è¿æ¥
func (d *NebulaDriver) Close() error {
    d.mu.Lock()
    defer d.mu.Unlock()
    
    if !d.connected {
        return nil
    }
    
    if d.session != nil {
        d.session.Release()
    }
    
    if d.pool != nil {
        d.pool.Close()
    }
    
    d.connected = false
    return nil
}

// IsConnected æ£€æŸ¥è¿æ¥çŠ¶æ€
func (d *NebulaDriver) IsConnected() bool {
    d.mu.RLock()
    defer d.mu.RUnlock()
    return d.connected
}

// Execute æ‰§è¡Œ nGQL æŸ¥è¯¢
func (d *NebulaDriver) Execute(ctx context.Context, query string) (*nebula.ResultSet, error) {
    if !d.IsConnected() {
        return nil, graphdb.ErrNotConnected
    }
    
    result, err := d.session.Execute(query)
    if err != nil {
        return nil, fmt.Errorf("execute query failed: %w", err)
    }
    
    if !result.IsSucceed() {
        return nil, fmt.Errorf("query failed: %s", result.GetErrorMsg())
    }
    
    return result, nil
}
```

#### config.go

```go
package nebula

import (
    "fmt"
    "time"
)

// Config NebulaGraph é…ç½®
type Config struct {
    // Addresses NebulaGraph åœ°å€åˆ—è¡¨
    // æ ¼å¼: "host:port"
    Addresses []string
    
    // Username ç”¨æˆ·å
    Username string
    
    // Password å¯†ç 
    Password string
    
    // Space ç©ºé—´åç§°
    Space string
    
    // Timeout è¿æ¥è¶…æ—¶
    Timeout time.Duration
    
    // IdleTime ç©ºé—²æ—¶é—´
    IdleTime time.Duration
    
    // MaxConnPoolSize æœ€å¤§è¿æ¥æ± å¤§å°
    MaxConnPoolSize int
    
    // MinConnPoolSize æœ€å°è¿æ¥æ± å¤§å°
    MinConnPoolSize int
}

// DefaultConfig è¿”å›é»˜è®¤é…ç½®
func DefaultConfig() Config {
    return Config{
        Addresses:       []string{"127.0.0.1:9669"},
        Username:        "root",
        Password:        "nebula",
        Space:           "langchain",
        Timeout:         30 * time.Second,
        IdleTime:        60 * time.Second,
        MaxConnPoolSize: 100,
        MinConnPoolSize: 10,
    }
}

// Validate éªŒè¯é…ç½®
func (c *Config) Validate() error {
    if len(c.Addresses) == 0 {
        return fmt.Errorf("addresses is required")
    }
    
    if c.Username == "" {
        return fmt.Errorf("username is required")
    }
    
    if c.Password == "" {
        return fmt.Errorf("password is required")
    }
    
    if c.Space == "" {
        return fmt.Errorf("space is required")
    }
    
    if c.MaxConnPoolSize <= 0 {
        c.MaxConnPoolSize = 100
    }
    
    if c.MinConnPoolSize <= 0 {
        c.MinConnPoolSize = 10
    }
    
    if c.Timeout <= 0 {
        c.Timeout = 30 * time.Second
    }
    
    return nil
}
```

### Phase 2.1.2: nGQL æŸ¥è¯¢æ„å»ºå™¨ (1å¤©)

**æ–‡ä»¶**: `queries.go`

```go
package nebula

import (
    "fmt"
    "strings"
)

// QueryBuilder nGQL æŸ¥è¯¢æ„å»ºå™¨
type QueryBuilder struct {
    space string
}

// NewQueryBuilder åˆ›å»ºæŸ¥è¯¢æ„å»ºå™¨
func NewQueryBuilder(space string) *QueryBuilder {
    return &QueryBuilder{space: space}
}

// InsertVertex æ„å»ºæ’å…¥èŠ‚ç‚¹æŸ¥è¯¢
func (qb *QueryBuilder) InsertVertex(id string, tag string, properties map[string]interface{}) string {
    // INSERT VERTEX Person(name, age) VALUES "person-1":("John", 30)
    
    if len(properties) == 0 {
        return fmt.Sprintf("INSERT VERTEX %s() VALUES \"%s\":()", tag, id)
    }
    
    // å±æ€§åç§°
    propNames := make([]string, 0, len(properties))
    propValues := make([]string, 0, len(properties))
    
    for key, value := range properties {
        propNames = append(propNames, key)
        propValues = append(propValues, formatValue(value))
    }
    
    return fmt.Sprintf("INSERT VERTEX %s(%s) VALUES \"%s\":(%s)",
        tag,
        strings.Join(propNames, ", "),
        id,
        strings.Join(propValues, ", "))
}

// FetchVertex æ„å»ºè·å–èŠ‚ç‚¹æŸ¥è¯¢
func (qb *QueryBuilder) FetchVertex(id string, tag string) string {
    // FETCH PROP ON Person "person-1"
    return fmt.Sprintf("FETCH PROP ON %s \"%s\" YIELD properties(vertex)", tag, id)
}

// UpdateVertex æ„å»ºæ›´æ–°èŠ‚ç‚¹æŸ¥è¯¢
func (qb *QueryBuilder) UpdateVertex(id string, tag string, properties map[string]interface{}) string {
    // UPDATE VERTEX "person-1" SET Person.age = 31
    
    sets := make([]string, 0, len(properties))
    for key, value := range properties {
        sets = append(sets, fmt.Sprintf("%s.%s = %s", tag, key, formatValue(value)))
    }
    
    return fmt.Sprintf("UPDATE VERTEX \"%s\" SET %s", id, strings.Join(sets, ", "))
}

// DeleteVertex æ„å»ºåˆ é™¤èŠ‚ç‚¹æŸ¥è¯¢
func (qb *QueryBuilder) DeleteVertex(id string) string {
    // DELETE VERTEX "person-1"
    return fmt.Sprintf("DELETE VERTEX \"%s\"", id)
}

// InsertEdge æ„å»ºæ’å…¥è¾¹æŸ¥è¯¢
func (qb *QueryBuilder) InsertEdge(source, target, edgeType string, properties map[string]interface{}) string {
    // INSERT EDGE WORKS_FOR(since) VALUES "person-1"->"org-1":(2020)
    
    if len(properties) == 0 {
        return fmt.Sprintf("INSERT EDGE %s() VALUES \"%s\"->\"%s\":()", edgeType, source, target)
    }
    
    propNames := make([]string, 0, len(properties))
    propValues := make([]string, 0, len(properties))
    
    for key, value := range properties {
        propNames = append(propNames, key)
        propValues = append(propValues, formatValue(value))
    }
    
    return fmt.Sprintf("INSERT EDGE %s(%s) VALUES \"%s\"->\"%s\":(%s)",
        edgeType,
        strings.Join(propNames, ", "),
        source,
        target,
        strings.Join(propValues, ", "))
}

// FetchEdge æ„å»ºè·å–è¾¹æŸ¥è¯¢
func (qb *QueryBuilder) FetchEdge(source, target, edgeType string) string {
    // FETCH PROP ON WORKS_FOR "person-1"->"org-1"
    return fmt.Sprintf("FETCH PROP ON %s \"%s\"->\"%s\" YIELD properties(edge)", edgeType, source, target)
}

// DeleteEdge æ„å»ºåˆ é™¤è¾¹æŸ¥è¯¢
func (qb *QueryBuilder) DeleteEdge(source, target, edgeType string) string {
    // DELETE EDGE WORKS_FOR "person-1"->"org-1"
    return fmt.Sprintf("DELETE EDGE %s \"%s\"->\"%s\"", edgeType, source, target)
}

// Traverse æ„å»ºéå†æŸ¥è¯¢
func (qb *QueryBuilder) Traverse(startID string, maxDepth int, direction string) string {
    // GO 1 TO 3 STEPS FROM "person-1" OVER * BIDIRECT YIELD dst(edge)
    
    dir := ""
    if direction == "BIDIRECT" {
        dir = "BIDIRECT"
    }
    
    return fmt.Sprintf("GO 1 TO %d STEPS FROM \"%s\" OVER * %s YIELD dst(edge) AS id",
        maxDepth, startID, dir)
}

// ShortestPath æ„å»ºæœ€çŸ­è·¯å¾„æŸ¥è¯¢
func (qb *QueryBuilder) ShortestPath(fromID, toID string, maxDepth int) string {
    // FIND SHORTEST PATH FROM "person-1" TO "org-1" OVER * UPTO 5 STEPS
    return fmt.Sprintf("FIND SHORTEST PATH FROM \"%s\" TO \"%s\" OVER * UPTO %d STEPS",
        fromID, toID, maxDepth)
}

// formatValue æ ¼å¼åŒ–å€¼
func formatValue(value interface{}) string {
    switch v := value.(type) {
    case string:
        return fmt.Sprintf("\"%s\"", v)
    case int, int8, int16, int32, int64:
        return fmt.Sprintf("%d", v)
    case uint, uint8, uint16, uint32, uint64:
        return fmt.Sprintf("%d", v)
    case float32, float64:
        return fmt.Sprintf("%f", v)
    case bool:
        return fmt.Sprintf("%t", v)
    default:
        return fmt.Sprintf("\"%v\"", v)
    }
}
```

---

## ğŸ“… æ—¶é—´è¡¨

| é˜¶æ®µ | ä»»åŠ¡ | å·¥ä½œé‡ | çŠ¶æ€ |
|------|------|--------|------|
| 2.1.1 | åŸºç¡€é©±åŠ¨å™¨ | 1å¤© | â³ å¾…å¼€å§‹ |
| 2.1.2 | nGQL æŸ¥è¯¢æ„å»ºå™¨ | 1å¤© | â³ å¾…å¼€å§‹ |
| 2.1.3 | å›¾æ“ä½œå®ç° | 1å¤© | â³ å¾…å¼€å§‹ |
| 2.1.4 | é›†æˆæµ‹è¯• | 0.5å¤© | â³ å¾…å¼€å§‹ |
| 2.1.5 | Docker + ç¤ºä¾‹ | 0.5å¤© | â³ å¾…å¼€å§‹ |

**æ€»è®¡**: 4å¤©

---

## ğŸ¯ éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½å®Œæ•´æ€§

- âœ… å®ç°æ‰€æœ‰ GraphDB æ¥å£æ–¹æ³•
- âœ… æ”¯æŒèŠ‚ç‚¹ CRUD æ“ä½œ
- âœ… æ”¯æŒè¾¹ CRUD æ“ä½œ
- âœ… æ”¯æŒå›¾éå†
- âœ… æ”¯æŒæœ€çŸ­è·¯å¾„

### è´¨é‡æ ‡å‡†

- âœ… å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%
- âœ… é›†æˆæµ‹è¯•é€šè¿‡
- âœ… æ€§èƒ½åŸºå‡†æµ‹è¯•
- âœ… å®Œæ•´çš„æ–‡æ¡£

### å…¼å®¹æ€§

- âœ… ä¸ç°æœ‰ GraphDB æ¥å£å®Œå…¨å…¼å®¹
- âœ… å¯ä¸ Neo4j æ— ç¼åˆ‡æ¢
- âœ… æ”¯æŒ Docker éƒ¨ç½²

---

**ä½œè€…**: LangChain-Go Team  
**ç‰ˆæœ¬**: v0.4.1 Phase 2.1  
**æ—¥æœŸ**: 2026-01-21
