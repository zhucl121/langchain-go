# A2A (Agent-to-Agent) åè®®è§„èŒƒæ–‡æ¡£

**ç‰ˆæœ¬**: v0.6.1  
**æ ‡å‡†**: LangChain-Go A2A Protocol  
**æ—¥æœŸ**: 2026-01-22

---

## ğŸ“‹ ç›®å½•

- [åè®®æ¦‚è¿°](#åè®®æ¦‚è¿°)
- [Agent æ¥å£](#agent-æ¥å£)
- [ä»»åŠ¡æ¨¡å‹](#ä»»åŠ¡æ¨¡å‹)
- [æ¶ˆæ¯äº¤æ¢](#æ¶ˆæ¯äº¤æ¢)
- [æ³¨å†Œä¸å‘ç°](#æ³¨å†Œä¸å‘ç°)
- [è·¯ç”±ç­–ç•¥](#è·¯ç”±ç­–ç•¥)
- [åä½œæ¨¡å¼](#åä½œæ¨¡å¼)
- [ä¼ è¾“å±‚](#ä¼ è¾“å±‚)

---

## åè®®æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ A2Aï¼Ÿ

**Agent-to-Agent (A2A)** åè®®æ˜¯ LangChain-Go å®šä¹‰çš„æ ‡å‡†åŒ– Agent é—´é€šä¿¡åè®®ï¼Œç”¨äºå®ç°åˆ†å¸ƒå¼ Multi-Agent ç³»ç»Ÿã€‚

### æ ¸å¿ƒæ¦‚å¿µ

1. **Agent** - å…·æœ‰ç‰¹å®šèƒ½åŠ›çš„æ™ºèƒ½ä½“
2. **Task** - éœ€è¦ Agent å®Œæˆçš„ä»»åŠ¡
3. **Registry** - Agent æ³¨å†Œå’Œå‘ç°ä¸­å¿ƒ
4. **Router** - ä»»åŠ¡è·¯ç”±å™¨
5. **Coordinator** - åä½œåè°ƒå™¨
6. **Message** - Agent é—´æ¶ˆæ¯

### è®¾è®¡ç›®æ ‡

- **æ ‡å‡†åŒ–** - ç»Ÿä¸€çš„ Agent é€šä¿¡æ¥å£
- **åˆ†å¸ƒå¼** - æ”¯æŒè·¨èŠ‚ç‚¹éƒ¨ç½²
- **å¯å‘ç°** - åŠ¨æ€ Agent æ³¨å†Œå’Œå‘ç°
- **æ™ºèƒ½è·¯ç”±** - è‡ªåŠ¨é€‰æ‹©æœ€åˆé€‚çš„ Agent
- **åä½œ** - æ”¯æŒå¤š Agent ååŒå·¥ä½œ

---

## Agent æ¥å£

### Agent ä¿¡æ¯

```go
type AgentInfo struct {
    ID          string         `json:"id"`
    Name        string         `json:"name"`
    Description string         `json:"description"`
    Version     string         `json:"version"`
    Vendor      string         `json:"vendor"`
    Type        AgentType      `json:"type"`
    Status      AgentStatus    `json:"status"`
    Metadata    map[string]any `json:"metadata"`
}
```

**Agent ç±»å‹**:
- `assistant` - é€šç”¨åŠ©æ‰‹
- `specialist` - ä¸“å®¶ Agent
- `coordinator` - åè°ƒå™¨

**Agent çŠ¶æ€**:
- `online` - åœ¨çº¿å¯ç”¨
- `busy` - å¿™ç¢Œä¸­
- `offline` - ç¦»çº¿
- `maintenance` - ç»´æŠ¤ä¸­

### Agent èƒ½åŠ›

```go
type AgentCapabilities struct {
    Capabilities       []string      `json:"capabilities"`
    Tools              []string      `json:"tools"`
    MessageFormats     []string      `json:"messageFormats"`
    Languages          []string      `json:"languages"`
    MaxConcurrentTasks int           `json:"maxConcurrentTasks"`
    AvgResponseTime    time.Duration `json:"avgResponseTime"`
}
```

**ç¤ºä¾‹**:

```json
{
  "capabilities": [
    "text_generation",
    "code_writing",
    "data_analysis"
  ],
  "tools": [
    "openai_gpt4",
    "python_executor"
  ],
  "messageFormats": ["text", "json", "markdown"],
  "languages": ["zh", "en"],
  "maxConcurrentTasks": 5,
  "avgResponseTime": "2s"
}
```

### æ ¸å¿ƒæ¥å£

```go
type A2AAgent interface {
    // Agent ä¿¡æ¯
    GetInfo(ctx context.Context) (*AgentInfo, error)
    GetCapabilities(ctx context.Context) (*AgentCapabilities, error)
    
    // ä»»åŠ¡å¤„ç†
    SendTask(ctx context.Context, task *Task) (*TaskResponse, error)
    GetTaskStatus(ctx context.Context, taskID string) (*TaskStatus, error)
    CancelTask(ctx context.Context, taskID string) error
    
    // æµå¼å¤„ç†
    StreamTask(ctx context.Context, task *Task) (<-chan *TaskEvent, error)
    
    // æ¶ˆæ¯äº¤æ¢
    SendMessage(ctx context.Context, msg *Message) error
    ReceiveMessages(ctx context.Context) (<-chan *Message, error)
    
    // åä½œ
    RequestHelp(ctx context.Context, req *HelpRequest) (*HelpResponse, error)
    OfferHelp(ctx context.Context, offer *HelpOffer) error
}
```

---

## ä»»åŠ¡æ¨¡å‹

### ä»»åŠ¡å®šä¹‰

```go
type Task struct {
    ID           string            `json:"id"`
    Type         TaskType          `json:"type"`
    Priority     Priority          `json:"priority"`
    Input        *TaskInput        `json:"input"`
    Context      map[string]any    `json:"context"`
    Requirements *TaskRequirements `json:"requirements,omitempty"`
    Deadline     *time.Time        `json:"deadline,omitempty"`
    Metadata     map[string]any    `json:"metadata"`
}
```

**ä»»åŠ¡ç±»å‹**:
- `query` - æŸ¥è¯¢ä»»åŠ¡
- `analyze` - åˆ†æä»»åŠ¡
- `generate` - ç”Ÿæˆä»»åŠ¡
- `execute` - æ‰§è¡Œä»»åŠ¡
- `complex` - å¤æ‚ä»»åŠ¡ï¼ˆéœ€è¦åˆ†è§£ï¼‰

**ä¼˜å…ˆçº§**:
- `low` - ä½ä¼˜å…ˆçº§
- `medium` - ä¸­ä¼˜å…ˆçº§
- `high` - é«˜ä¼˜å…ˆçº§
- `urgent` - ç´§æ€¥

### ä»»åŠ¡è¾“å…¥

```go
type TaskInput struct {
    Type    string         `json:"type"`
    Content string         `json:"content,omitempty"`
    Data    map[string]any `json:"data,omitempty"`
    Files   []FileRef      `json:"files,omitempty"`
}
```

**è¾“å…¥ç±»å‹**:
- `text` - æ–‡æœ¬è¾“å…¥
- `document` - æ–‡æ¡£
- `data` - ç»“æ„åŒ–æ•°æ®
- `file` - æ–‡ä»¶å¼•ç”¨

**ç¤ºä¾‹**:

```json
{
  "type": "text",
  "content": "åˆ†æè¿™ä¸ªæ•°æ®é›†çš„ç»Ÿè®¡ç‰¹å¾"
}
```

```json
{
  "type": "data",
  "data": {
    "dataset": [...],
    "columns": ["age", "income", "education"]
  }
}
```

### ä»»åŠ¡è¦æ±‚

```go
type TaskRequirements struct {
    Quality       string         `json:"quality,omitempty"`
    MaxDuration   int            `json:"maxDuration,omitempty"`
    RequiredTools []string       `json:"requiredTools,omitempty"`
    Constraints   map[string]any `json:"constraints,omitempty"`
}
```

**è´¨é‡çº§åˆ«**:
- `draft` - è‰ç¨¿è´¨é‡
- `standard` - æ ‡å‡†è´¨é‡
- `high` - é«˜è´¨é‡

**ç¤ºä¾‹**:

```json
{
  "quality": "high",
  "maxDuration": 300,
  "requiredTools": ["data_analysis", "statistics"],
  "constraints": {
    "maxMemory": "4GB",
    "confidenceThreshold": 0.8
  }
}
```

### ä»»åŠ¡å“åº”

```go
type TaskResponse struct {
    TaskID        string         `json:"taskId"`
    Status        TaskStatus     `json:"status"`
    Result        *TaskResult    `json:"result,omitempty"`
    Error         *TaskError     `json:"error,omitempty"`
    Progress      float64        `json:"progress"`
    EstimatedTime *time.Duration `json:"estimatedTime,omitempty"`
    Metadata      map[string]any `json:"metadata"`
}
```

**ä»»åŠ¡çŠ¶æ€**:
- `pending` - å¾…å¤„ç†
- `running` - è¿è¡Œä¸­
- `completed` - å·²å®Œæˆ
- `failed` - å¤±è´¥
- `cancelled` - å·²å–æ¶ˆ

### ä»»åŠ¡ç»“æœ

```go
type TaskResult struct {
    Type       string         `json:"type"`
    Content    string         `json:"content,omitempty"`
    Data       map[string]any `json:"data,omitempty"`
    Files      []FileRef      `json:"files,omitempty"`
    Artifacts  []Artifact     `json:"artifacts,omitempty"`
    Confidence float64        `json:"confidence,omitempty"`
}
```

**ç¤ºä¾‹**:

```json
{
  "type": "text",
  "content": "æ•°æ®é›†ç»Ÿè®¡åˆ†æç»“æœï¼šå¹³å‡å€¼ 45.2ï¼Œæ ‡å‡†å·® 12.3...",
  "confidence": 0.95
}
```

---

## æ¶ˆæ¯äº¤æ¢

### æ¶ˆæ¯æ ¼å¼

```go
type Message struct {
    ID        string         `json:"id"`
    From      string         `json:"from"`
    To        string         `json:"to"`
    Type      MessageType    `json:"type"`
    Content   string         `json:"content"`
    Data      map[string]any `json:"data,omitempty"`
    ReplyTo   string         `json:"replyTo,omitempty"`
    Timestamp time.Time      `json:"timestamp"`
    Metadata  map[string]any `json:"metadata"`
}
```

**æ¶ˆæ¯ç±»å‹**:
- `request` - è¯·æ±‚
- `response` - å“åº”
- `notification` - é€šçŸ¥
- `broadcast` - å¹¿æ’­

### æ¶ˆæ¯ç¤ºä¾‹

#### è¯·æ±‚æ¶ˆæ¯

```json
{
  "id": "msg-123",
  "from": "agent-1",
  "to": "agent-2",
  "type": "request",
  "content": "éœ€è¦ä½ ååŠ©åˆ†æè¿™ä¸ªæ•°æ®",
  "data": {
    "dataset": [...]
  },
  "timestamp": "2026-01-22T10:00:00Z"
}
```

#### å“åº”æ¶ˆæ¯

```json
{
  "id": "msg-124",
  "from": "agent-2",
  "to": "agent-1",
  "type": "response",
  "content": "åˆ†æå®Œæˆ",
  "data": {
    "result": {...}
  },
  "replyTo": "msg-123",
  "timestamp": "2026-01-22T10:05:00Z"
}
```

#### é€šçŸ¥æ¶ˆæ¯

```json
{
  "id": "msg-125",
  "from": "agent-1",
  "to": "coordinator",
  "type": "notification",
  "content": "ä»»åŠ¡å®Œæˆ",
  "data": {
    "taskId": "task-456",
    "status": "completed"
  },
  "timestamp": "2026-01-22T10:10:00Z"
}
```

---

## æ³¨å†Œä¸å‘ç°

### Agent æ³¨å†Œ

#### gRPC æ³¨å†Œæ¥å£

```protobuf
service AgentRegistry {
  rpc Register(RegisterRequest) returns (RegisterResponse);
  rpc Unregister(UnregisterRequest) returns (UnregisterResponse);
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  rpc UpdateStatus(UpdateStatusRequest) returns (UpdateStatusResponse);
}

message RegisterRequest {
  AgentInfo info = 1;
  AgentCapabilities capabilities = 2;
  string endpoint = 3;
}

message RegisterResponse {
  bool success = 1;
  string message = 2;
  string registrationId = 3;
}
```

#### REST API

**æ³¨å†Œ Agent**:

```http
POST /api/v1/agents/register
Content-Type: application/json

{
  "info": {
    "id": "agent-1",
    "name": "Research Agent",
    "type": "specialist"
  },
  "capabilities": {
    "capabilities": ["research", "search"],
    "tools": ["search", "web_scraper"]
  },
  "endpoint": "http://agent-1:8080"
}
```

**å“åº”**:

```json
{
  "success": true,
  "registrationId": "reg-123",
  "message": "Agent registered successfully"
}
```

### Agent å‘ç°

#### æŒ‰ ID æŸ¥æ‰¾

```http
GET /api/v1/agents/{agentId}
```

#### æŒ‰èƒ½åŠ›æŸ¥æ‰¾

```http
GET /api/v1/agents/search?capability=research
```

**å“åº”**:

```json
{
  "agents": [
    {
      "id": "agent-1",
      "name": "Research Agent",
      "capabilities": ["research", "search"],
      "status": "online",
      "endpoint": "http://agent-1:8080"
    },
    {
      "id": "agent-2",
      "name": "Data Analyst",
      "capabilities": ["research", "analysis"],
      "status": "online",
      "endpoint": "http://agent-2:8080"
    }
  ],
  "total": 2
}
```

#### æŒ‰ç±»å‹æŸ¥æ‰¾

```http
GET /api/v1/agents/search?type=specialist
```

### å¥åº·æ£€æŸ¥

```http
GET /api/v1/agents/{agentId}/health
```

**å“åº”**:

```json
{
  "agentId": "agent-1",
  "status": "healthy",
  "latency": "15ms",
  "lastHeartbeat": "2026-01-22T10:00:00Z",
  "uptime": "24h"
}
```

### Consul é›†æˆ

#### æœåŠ¡æ³¨å†Œ

```json
{
  "Name": "langchain-go-agent",
  "ID": "agent-1",
  "Address": "192.168.1.100",
  "Port": 8080,
  "Tags": [
    "a2a",
    "specialist",
    "research"
  ],
  "Meta": {
    "capabilities": "research,search,analysis",
    "version": "0.6.1"
  },
  "Check": {
    "HTTP": "http://192.168.1.100:8080/health",
    "Interval": "10s",
    "Timeout": "5s"
  }
}
```

#### æœåŠ¡å‘ç°

```bash
# æŸ¥è¯¢æ‰€æœ‰ Agent
curl http://localhost:8500/v1/catalog/service/langchain-go-agent

# æŒ‰æ ‡ç­¾è¿‡æ»¤
curl http://localhost:8500/v1/catalog/service/langchain-go-agent?tag=research
```

---

## è·¯ç”±ç­–ç•¥

### è·¯ç”±æ¥å£

```go
type TaskRouter interface {
    Route(ctx context.Context, task *Task) (A2AAgent, error)
    RouteMultiple(ctx context.Context, task *Task, count int) ([]A2AAgent, error)
    RouteWithLoadBalancing(ctx context.Context, task *Task) (A2AAgent, error)
}
```

### ç­–ç•¥ç±»å‹

#### 1. èƒ½åŠ›åŒ¹é…ç­–ç•¥

åŸºäº Agent èƒ½åŠ›å’Œä»»åŠ¡è¦æ±‚è¿›è¡ŒåŒ¹é…ã€‚

**è¯„åˆ†å…¬å¼**:

```
Score = MatchedCapabilities / RequiredCapabilities
```

**ç¤ºä¾‹**:

```go
task.Requirements.RequiredTools = []string{"search", "analysis", "writing"}

agent1.Capabilities = []string{"search", "analysis"}        // Score: 2/3 = 0.67
agent2.Capabilities = []string{"search", "analysis", "writing", "coding"}  // Score: 3/3 = 1.0

// é€‰æ‹© agent2
```

#### 2. è´Ÿè½½å‡è¡¡ç­–ç•¥

åŸºäº Agent å½“å‰è´Ÿè½½è¿›è¡Œé€‰æ‹©ã€‚

**è´Ÿè½½æŒ‡æ ‡**:
- å½“å‰ä»»åŠ¡æ•°
- CPU ä½¿ç”¨ç‡
- å†…å­˜ä½¿ç”¨ç‡
- é˜Ÿåˆ—é•¿åº¦

**è¯„åˆ†å…¬å¼**:

```
LoadScore = 1 - (CurrentTasks / MaxTasks)
```

#### 3. æ€§èƒ½ä¼˜å…ˆç­–ç•¥

åŸºäº Agent å†å²æ€§èƒ½è¿›è¡Œé€‰æ‹©ã€‚

**æ€§èƒ½æŒ‡æ ‡**:
- å¹³å‡å“åº”æ—¶é—´
- ä»»åŠ¡æˆåŠŸç‡
- ååé‡

**è¯„åˆ†å…¬å¼**:

```
PerfScore = SuccessRate * (1 - NormalizedResponseTime)
```

#### 4. æ··åˆç­–ç•¥ï¼ˆæ¨èï¼‰

ç»¼åˆå¤šä¸ªç»´åº¦è¿›è¡Œè¯„åˆ†ã€‚

**è¯„åˆ†å…¬å¼**:

```
TotalScore = w1 * CapabilityScore + 
             w2 * LoadScore + 
             w3 * PerformanceScore + 
             w4 * ReputationScore
```

**é»˜è®¤æƒé‡**:

```go
weights := &ScoringWeights{
    CapabilityMatch: 0.4,  // 40%
    Load:            0.3,  // 30%
    Performance:     0.2,  // 20%
    Reputation:      0.1,  // 10%
}
```

### è·¯ç”±ç¤ºä¾‹

```go
// åˆ›å»ºè·¯ç”±å™¨
router := a2a.NewSmartTaskRouter(registry, RouterConfig{
    Strategy: StrategyHybrid,
    Scorer: &AgentScorer{
        Weights: &ScoringWeights{
            CapabilityMatch: 0.4,
            Load:            0.3,
            Performance:     0.2,
            Reputation:      0.1,
        },
    },
})

// è·¯ç”±ä»»åŠ¡
agent, err := router.Route(ctx, task)
```

---

## åä½œæ¨¡å¼

### é¡ºåºåä½œ

å¤šä¸ª Agent æŒ‰é¡ºåºå¤„ç†ä»»åŠ¡ã€‚

```
Task â†’ Agent1 â†’ Result1 â†’ Agent2 â†’ Result2 â†’ Agent3 â†’ Final Result
```

**å®ç°**:

```go
result1 := agent1.SendTask(ctx, task)
task2 := CreateTaskFromResult(result1)
result2 := agent2.SendTask(ctx, task2)
task3 := CreateTaskFromResult(result2)
finalResult := agent3.SendTask(ctx, task3)
```

### å¹¶è¡Œåä½œ

å¤šä¸ª Agent å¹¶è¡Œå¤„ç†å­ä»»åŠ¡ã€‚

```
        â”Œâ”€â†’ Agent1 â†’ Result1 â”€â”
Task â”€â”€â”€â”¼â”€â†’ Agent2 â†’ Result2 â”€â”¼â”€â†’ Aggregate â†’ Final Result
        â””â”€â†’ Agent3 â†’ Result3 â”€â”˜
```

**å®ç°**:

```go
var wg sync.WaitGroup
results := make([]*TaskResult, 3)

for i, agent := range agents {
    wg.Add(1)
    go func(idx int, a A2AAgent) {
        defer wg.Done()
        results[idx], _ = a.SendTask(ctx, subTasks[idx])
    }(i, agent)
}

wg.Wait()
finalResult := AggregateResults(results)
```

### å±‚æ¬¡åŒ–åä½œ

Coordinator åè°ƒå¤šä¸ª Specialist Agentã€‚

```
                    Coordinator
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                â–¼                â–¼
    Researcher       Analyst          Writer
```

**å®ç°**:

```go
coordinator := a2a.NewCollaborationCoordinator(registry, router)

// å¤æ‚ä»»åŠ¡è‡ªåŠ¨åˆ†è§£å’Œåè°ƒ
result, err := coordinator.Coordinate(ctx, complexTask)
```

### ååŠ©è¯·æ±‚æ¨¡å¼

Agent å¯ä»¥è¯·æ±‚å…¶ä»– Agent ååŠ©ã€‚

```go
// Agent1 é‡åˆ°å›°éš¾
helpRequest := &HelpRequest{
    RequestID:   uuid.New().String(),
    RequesterID: "agent-1",
    Task:        difficultTask,
    Reason:      "éœ€è¦ä¸“ä¸šçš„æ•°æ®åˆ†æèƒ½åŠ›",
    Requirements: &HelpRequirements{
        RequiredCapabilities: []string{"data_analysis"},
        MaxWaitTime:          30 * time.Second,
    },
}

// å‘é€ååŠ©è¯·æ±‚
response, err := agent1.RequestHelp(ctx, helpRequest)

// Agent2 æä¾›ååŠ©
if response.Success {
    result := agent2.SendTask(ctx, difficultTask)
}
```

---

## ä¼ è¾“å±‚

### gRPC

#### æœåŠ¡å®šä¹‰

```protobuf
service A2AService {
  // ä»»åŠ¡å¤„ç†
  rpc SendTask(SendTaskRequest) returns (SendTaskResponse);
  rpc GetTaskStatus(GetTaskStatusRequest) returns (GetTaskStatusResponse);
  rpc CancelTask(CancelTaskRequest) returns (CancelTaskResponse);
  rpc StreamTask(SendTaskRequest) returns (stream TaskEvent);
  
  // æ¶ˆæ¯äº¤æ¢
  rpc SendMessage(SendMessageRequest) returns (SendMessageResponse);
  rpc ReceiveMessages(ReceiveMessagesRequest) returns (stream Message);
  
  // åä½œ
  rpc RequestHelp(HelpRequest) returns (HelpResponse);
}

message SendTaskRequest {
  Task task = 1;
}

message SendTaskResponse {
  TaskResponse response = 1;
}
```

#### è¿æ¥ç¤ºä¾‹

```go
// è¿æ¥åˆ° Agent
conn, err := grpc.Dial("agent-1:8080", grpc.WithInsecure())
defer conn.Close()

client := pb.NewA2AServiceClient(conn)

// å‘é€ä»»åŠ¡
resp, err := client.SendTask(ctx, &pb.SendTaskRequest{
    Task: task,
})
```

### HTTP REST API

#### å‘é€ä»»åŠ¡

```http
POST /api/v1/tasks
Content-Type: application/json

{
  "id": "task-123",
  "type": "analyze",
  "priority": "high",
  "input": {
    "type": "text",
    "content": "åˆ†æè¿™ä¸ªæ•°æ®"
  }
}
```

**å“åº”**:

```json
{
  "taskId": "task-123",
  "status": "running",
  "progress": 0.0,
  "estimatedTime": "30s"
}
```

#### è·å–ä»»åŠ¡çŠ¶æ€

```http
GET /api/v1/tasks/{taskId}
```

**å“åº”**:

```json
{
  "taskId": "task-123",
  "status": "completed",
  "result": {
    "type": "text",
    "content": "åˆ†æç»“æœ..."
  },
  "progress": 1.0
}
```

#### å–æ¶ˆä»»åŠ¡

```http
DELETE /api/v1/tasks/{taskId}
```

---

## å®‰å…¨è€ƒè™‘

### 1. è®¤è¯

```go
// Token è®¤è¯
ctx := metadata.AppendToOutgoingContext(ctx,
    "authorization", "Bearer "+token,
)

// mTLS
creds, _ := credentials.NewClientTLSFromFile("ca.crt", "")
conn, _ := grpc.Dial("agent-1:8080", grpc.WithTransportCredentials(creds))
```

### 2. æˆæƒï¼ˆé›†æˆ v0.6.0 RBACï¼‰

```go
// æ£€æŸ¥æƒé™
req := &rbac.PermissionRequest{
    UserID:     agentID,
    Resource:   "a2a_agent",
    Action:     "execute_task",
    ResourceID: task.ID,
}

if err := rbacManager.CheckPermission(ctx, req); err != nil {
    return errors.New("permission denied")
}
```

### 3. å®¡è®¡ï¼ˆé›†æˆ v0.6.0 å®¡è®¡ï¼‰

```go
// è®°å½•å®¡è®¡æ—¥å¿—
event := &audit.AuditEvent{
    TenantID:   GetTenantID(ctx),
    UserID:     agentID,
    Action:     "a2a.task.execute",
    Resource:   "task",
    ResourceID: task.ID,
    Status:     "success",
    Timestamp:  time.Now(),
}

auditLogger.Log(ctx, event)
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. è¿æ¥æ± 

```go
type AgentPool struct {
    clients map[string]pb.A2AServiceClient
    conns   map[string]*grpc.ClientConn
    mu      sync.RWMutex
}

func (p *AgentPool) GetClient(agentID string) (pb.A2AServiceClient, error) {
    p.mu.RLock()
    client, ok := p.clients[agentID]
    p.mu.RUnlock()
    
    if ok {
        return client, nil
    }
    
    // åˆ›å»ºæ–°è¿æ¥
    conn, err := grpc.Dial(agentEndpoint, grpc.WithInsecure())
    if err != nil {
        return nil, err
    }
    
    client = pb.NewA2AServiceClient(conn)
    
    p.mu.Lock()
    p.clients[agentID] = client
    p.conns[agentID] = conn
    p.mu.Unlock()
    
    return client, nil
}
```

### 2. æ‰¹é‡ä»»åŠ¡

```go
// æ‰¹é‡å‘é€ä»»åŠ¡
func SendTasksBatch(ctx context.Context, agents []A2AAgent, tasks []*Task) ([]*TaskResponse, error) {
    var wg sync.WaitGroup
    responses := make([]*TaskResponse, len(tasks))
    
    for i, task := range tasks {
        wg.Add(1)
        go func(idx int, t *Task) {
            defer wg.Done()
            agent := agents[idx % len(agents)]  // è´Ÿè½½å‡è¡¡
            responses[idx], _ = agent.SendTask(ctx, t)
        }(i, task)
    }
    
    wg.Wait()
    return responses, nil
}
```

### 3. ç»“æœç¼“å­˜

```go
// ç¼“å­˜ä»»åŠ¡ç»“æœ
type ResultCache struct {
    cache map[string]*TaskResult
    mu    sync.RWMutex
}

func (c *ResultCache) Get(taskID string) (*TaskResult, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    result, ok := c.cache[taskID]
    return result, ok
}
```

---

## æ•…éšœå¤„ç†

### 1. è¶…æ—¶é‡è¯•

```go
func SendTaskWithRetry(ctx context.Context, agent A2AAgent, task *Task, maxRetries int) (*TaskResponse, error) {
    var response *TaskResponse
    var err error
    
    for i := 0; i < maxRetries; i++ {
        ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()
        
        response, err = agent.SendTask(ctx, task)
        if err == nil {
            return response, nil
        }
        
        if err != context.DeadlineExceeded {
            return nil, err  // éè¶…æ—¶é”™è¯¯ï¼Œä¸é‡è¯•
        }
        
        time.Sleep(time.Second * time.Duration(i+1))  // æŒ‡æ•°é€€é¿
    }
    
    return nil, err
}
```

### 2. æ•…éšœè½¬ç§»

```go
// ä½¿ç”¨ v0.5.0 æ•…éšœè½¬ç§»æœºåˆ¶
failoverManager := failover.NewManager(failover.Config{
    MaxRetries:     3,
    RetryDelay:     time.Second,
    CircuitBreaker: circuitbreaker.New(circuitbreaker.Config{
        Threshold:   5,
        Timeout:     30 * time.Second,
        MaxRequests: 3,
    }),
})

response, err := failoverManager.Execute(ctx, func() (any, error) {
    return agent.SendTask(ctx, task)
})
```

---

## ç›‘æ§æŒ‡æ ‡

### Prometheus æŒ‡æ ‡

```go
var (
    tasksSent = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "a2a_tasks_sent_total",
            Help: "Total number of tasks sent",
        },
        []string{"agent_id", "task_type"},
    )
    
    taskDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "a2a_task_duration_seconds",
            Help:    "Task execution duration",
            Buckets: prometheus.DefBuckets,
        },
        []string{"agent_id", "task_type"},
    )
    
    agentHealth = prometheus.NewGaugeVec(
        prometheus.GaugeOpts{
            Name: "a2a_agent_health",
            Help: "Agent health status (1=healthy, 0=unhealthy)",
        },
        []string{"agent_id"},
    )
)
```

---

## å‚è€ƒå®ç°

### Go å®¢æˆ·ç«¯

```go
package a2aclient

import (
    "context"
    "github.com/zhucl121/langchain-go/pkg/protocols/a2a"
    "google.golang.org/grpc"
)

type Client struct {
    conn   *grpc.ClientConn
    client pb.A2AServiceClient
}

func New(endpoint string) (*Client, error) {
    conn, err := grpc.Dial(endpoint, grpc.WithInsecure())
    if err != nil {
        return nil, err
    }
    
    return &Client{
        conn:   conn,
        client: pb.NewA2AServiceClient(conn),
    }, nil
}

func (c *Client) SendTask(ctx context.Context, task *Task) (*TaskResponse, error) {
    resp, err := c.client.SendTask(ctx, &pb.SendTaskRequest{
        Task: task,
    })
    if err != nil {
        return nil, err
    }
    
    return resp.Response, nil
}
```

---

## å‚è€ƒèµ„æ–™

- [gRPC å®˜æ–¹æ–‡æ¡£](https://grpc.io/)
- [Consul æœåŠ¡å‘ç°](https://www.consul.io/)
- [Prometheus ç›‘æ§](https://prometheus.io/)

---

**åˆ›å»ºæ—¥æœŸ**: 2026-01-22  
**æœ€åæ›´æ–°**: 2026-01-22  
**ç‰ˆæœ¬**: v0.6.1
