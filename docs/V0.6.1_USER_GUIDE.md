# v0.6.1 ç”¨æˆ·æŒ‡å—

**ç‰ˆæœ¬**: v0.6.1  
**ä¸»é¢˜**: æ ‡å‡†åŒ–åè®®é›†æˆ - MCP & A2A  
**å‘å¸ƒæ—¥æœŸ**: 2026-01-24ï¼ˆé¢„è®¡ï¼‰

---

## ğŸ“– ç›®å½•

- [ç®€ä»‹](#ç®€ä»‹)
- [MCP åè®®ä½¿ç”¨](#mcp-åè®®ä½¿ç”¨)
  - [å¿«é€Ÿå¼€å§‹](#mcp-å¿«é€Ÿå¼€å§‹)
  - [MCP Server å¼€å‘](#mcp-server-å¼€å‘)
  - [MCP Client ä½¿ç”¨](#mcp-client-ä½¿ç”¨)
  - [ä¸ Claude Desktop é›†æˆ](#ä¸-claude-desktop-é›†æˆ)
- [A2A åè®®ä½¿ç”¨](#a2a-åè®®ä½¿ç”¨)
  - [å¿«é€Ÿå¼€å§‹](#a2a-å¿«é€Ÿå¼€å§‹)
  - [Agent æ³¨å†Œä¸å‘ç°](#agent-æ³¨å†Œä¸å‘ç°)
  - [ä»»åŠ¡è·¯ç”±](#ä»»åŠ¡è·¯ç”±)
  - [å¤š Agent åä½œ](#å¤š-agent-åä½œ)
- [åè®®æ¡¥æ¥](#åè®®æ¡¥æ¥)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
- [æ•…éšœæ’æŸ¥](#æ•…éšœæ’æŸ¥)

---

## ç®€ä»‹

v0.6.1 å¼•å…¥äº†ä¸¤ä¸ªé‡è¦çš„æ ‡å‡†åŒ–åè®®ï¼š

1. **MCP (Model Context Protocol)** - Anthropic æå‡ºçš„æ ‡å‡†åè®®ï¼Œç”¨äº AI å·¥å…·å’Œå¤–éƒ¨ç³»ç»Ÿçš„äº’æ“ä½œ
2. **A2A (Agent-to-Agent)** - æ ‡å‡†åŒ–çš„ Agent é—´é€šä¿¡åè®®ï¼Œæ”¯æŒåˆ†å¸ƒå¼åä½œ

è¿™ä¸¤ä¸ªåè®®ä½¿ LangChain-Go èƒ½å¤Ÿï¼š
- ä¸ Claude Desktop ç­‰å·¥å…·äº’æ“ä½œ
- å®ç°è·¨ç³»ç»Ÿã€è·¨è¯­è¨€çš„ Agent åä½œ
- æ ‡å‡†åŒ–çš„èµ„æºå’Œå·¥å…·è®¿é—®
- åˆ†å¸ƒå¼ Multi-Agent ç³»ç»Ÿ

---

## MCP åè®®ä½¿ç”¨

### MCP å¿«é€Ÿå¼€å§‹

#### å®‰è£…ä¾èµ–

```bash
go get github.com/zhucl121/langchain-go@v0.6.1
```

#### 5 åˆ†é’Ÿåˆ›å»ºç¬¬ä¸€ä¸ª MCP Server

```go
package main

import (
    "context"
    "log"
    
    "github.com/zhucl121/langchain-go/pkg/protocols/mcp"
    "github.com/zhucl121/langchain-go/core/tools"
)

func main() {
    // 1. åˆ›å»º MCP Server
    server := mcp.NewServer(mcp.ServerConfig{
        Name:        "my-first-server",
        Version:     "1.0.0",
        Description: "æˆ‘çš„ç¬¬ä¸€ä¸ª MCP Server",
    })
    
    // 2. æ³¨å†Œä¸€ä¸ªå·¥å…·
    calculator := tools.NewCalculatorTool()
    if err := server.RegisterTool(calculator); err != nil {
        log.Fatal(err)
    }
    
    // 3. æ³¨å†Œä¸€ä¸ªèµ„æº
    resource := &mcp.Resource{
        URI:         "file:///docs",
        Name:        "Documentation",
        Description: "æ–‡æ¡£ç›®å½•",
        MimeType:    "text/plain",
    }
    
    provider := mcp.NewFileSystemProvider("/path/to/docs")
    if err := server.RegisterResource(resource, provider); err != nil {
        log.Fatal(err)
    }
    
    // 4. å¯åŠ¨ Serverï¼ˆStdio ä¼ è¾“ï¼‰
    transport := mcp.NewStdioTransport()
    log.Println("MCP Server å¯åŠ¨æˆåŠŸ")
    
    if err := server.Serve(context.Background(), transport); err != nil {
        log.Fatal(err)
    }
}
```

ç¼–è¯‘å¹¶è¿è¡Œï¼š

```bash
go build -o my_mcp_server main.go
./my_mcp_server
```

---

### MCP Server å¼€å‘

#### 1. åˆ›å»ºå’Œé…ç½® Server

```go
// å®Œæ•´é…ç½®ç¤ºä¾‹
config := mcp.ServerConfig{
    Name:        "company-ai-server",
    Version:     "1.0.0",
    Vendor:      "Company Inc.",
    Description: "å…¬å¸ AI æœåŠ¡å™¨",
    
    // å£°æ˜èƒ½åŠ›
    Capabilities: mcp.ServerCapabilities{
        Resources: &mcp.ResourceCapability{
            Subscribe: true,  // æ”¯æŒèµ„æºè®¢é˜…
        },
        Tools: &mcp.ToolCapability{
            ListChanged: true,  // å·¥å…·åˆ—è¡¨å¯å˜
        },
        Prompts: &mcp.PromptCapability{},
        Sampling: &mcp.SamplingCapability{},
    },
    
    // å®‰å…¨é…ç½®ï¼ˆå¯é€‰ï¼Œé›†æˆ v0.6.0 RBACï¼‰
    Auth: mcp.AuthConfig{
        Enabled: true,
        RBAC:    rbacManager,
    },
}

server := mcp.NewServer(config)
```

#### 2. èµ„æºç®¡ç†

##### æ³¨å†Œæ–‡ä»¶ç³»ç»Ÿèµ„æº

```go
// åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿæä¾›è€…
fsProvider := mcp.NewFileSystemProvider("/data/documents")

// æ³¨å†Œèµ„æº
resource := &mcp.Resource{
    URI:         "file:///documents",
    Name:        "Company Documents",
    Description: "å…¬å¸æ–‡æ¡£åº“",
    MimeType:    "text/plain",
    Metadata: map[string]any{
        "category": "internal",
        "access":   "restricted",
    },
}

server.RegisterResource(resource, fsProvider)
```

##### æ³¨å†Œæ•°æ®åº“èµ„æº

```go
// åˆ›å»ºæ•°æ®åº“æä¾›è€…
dbProvider := mcp.NewDatabaseProvider(db, mcp.DatabaseConfig{
    Type:   "postgresql",
    Tables: []string{"customers", "orders", "products"},
})

// æ³¨å†Œæ•°æ®åº“èµ„æº
resource := &mcp.Resource{
    URI:         "db://company/customers",
    Name:        "Customer Database",
    Description: "å®¢æˆ·æ•°æ®åº“",
    MimeType:    "application/sql",
}

server.RegisterResource(resource, dbProvider)
```

##### æ³¨å†Œå‘é‡å­˜å‚¨èµ„æº

```go
// åˆ›å»ºå‘é‡å­˜å‚¨æä¾›è€…
vsProvider := mcp.NewVectorStoreProvider(vectorStore, mcp.VectorStoreConfig{
    CollectionName: "company_docs",
    EmbeddingModel: embedder,
})

// æ³¨å†Œå‘é‡å­˜å‚¨èµ„æº
resource := &mcp.Resource{
    URI:         "vector://company_docs",
    Name:        "Company Knowledge Base",
    Description: "å…¬å¸çŸ¥è¯†åº“ï¼ˆå‘é‡æœç´¢ï¼‰",
    MimeType:    "application/json",
}

server.RegisterResource(resource, vsProvider)
```

##### èµ„æºè®¢é˜…

```go
// å®¢æˆ·ç«¯å¯ä»¥è®¢é˜…èµ„æºæ›´æ–°
server.OnResourceUpdate(func(uri string) {
    log.Printf("èµ„æºæ›´æ–°: %s", uri)
    
    // é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
    server.NotifyResourceUpdate(uri, &mcp.ResourceUpdate{
        URI:       uri,
        Timestamp: time.Now(),
        ChangeType: "modified",
    })
})
```

#### 3. å·¥å…·æ³¨å†Œ

##### æ³¨å†Œç°æœ‰å·¥å…·ï¼ˆè‡ªåŠ¨æ¡¥æ¥ï¼‰

```go
// LangChain-Go ç°æœ‰å·¥å…·ä¼šè‡ªåŠ¨æ¡¥æ¥ä¸º MCP å·¥å…·
calculator := tools.NewCalculatorTool()
server.RegisterTool(calculator)

search := tools.NewDuckDuckGoSearchTool(nil)
server.RegisterTool(search)

// æ‰¹é‡æ³¨å†Œ
allTools := []tools.Tool{
    tools.NewCalculatorTool(),
    tools.NewDuckDuckGoSearchTool(nil),
    tools.NewFileReaderTool(),
}

for _, tool := range allTools {
    server.RegisterTool(tool)
}
```

##### è‡ªå®šä¹‰ MCP å·¥å…·

```go
// å®šä¹‰è‡ªå®šä¹‰å·¥å…·
customTool := &mcp.MCPTool{
    Name:        "custom_analysis",
    Description: "è‡ªå®šä¹‰æ•°æ®åˆ†æå·¥å…·",
    InputSchema: map[string]any{
        "type": "object",
        "properties": map[string]any{
            "data": map[string]any{
                "type":        "array",
                "description": "è¦åˆ†æçš„æ•°æ®",
            },
            "method": map[string]any{
                "type":        "string",
                "enum":        []string{"mean", "median", "std"},
                "description": "åˆ†ææ–¹æ³•",
            },
        },
        "required": []string{"data", "method"},
    },
    Handler: func(ctx context.Context, args map[string]any) (*mcp.ToolResult, error) {
        data := args["data"].([]float64)
        method := args["method"].(string)
        
        var result float64
        switch method {
        case "mean":
            result = calculateMean(data)
        case "median":
            result = calculateMedian(data)
        case "std":
            result = calculateStd(data)
        }
        
        return &mcp.ToolResult{
            Content: []mcp.ContentBlock{
                {
                    Type: "text",
                    Text: fmt.Sprintf("åˆ†æç»“æœ: %.2f", result),
                },
            },
        }, nil
    },
}

server.RegisterMCPTool(customTool)
```

#### 4. Prompt ç®¡ç†

```go
// æ³¨å†Œ Prompt
prompt := &mcp.Prompt{
    Name:        "code_review",
    Description: "ä»£ç å®¡æŸ¥ Prompt",
    Arguments: []mcp.PromptArgument{
        {
            Name:        "code",
            Description: "è¦å®¡æŸ¥çš„ä»£ç ",
            Required:    true,
        },
        {
            Name:        "language",
            Description: "ç¼–ç¨‹è¯­è¨€",
            Required:    false,
        },
    },
}

server.RegisterPrompt(prompt, func(ctx context.Context, args map[string]any) (*mcp.PromptResult, error) {
    code := args["code"].(string)
    language := args["language"].(string)
    
    promptText := fmt.Sprintf(
        "è¯·å®¡æŸ¥ä»¥ä¸‹ %s ä»£ç ï¼ŒæŒ‡å‡ºæ½œåœ¨é—®é¢˜å’Œæ”¹è¿›å»ºè®®ï¼š\n\n%s",
        language, code,
    )
    
    return &mcp.PromptResult{
        Prompt: promptText,
        Arguments: args,
    }, nil
})
```

#### 5. é‡‡æ ·æ”¯æŒï¼ˆLLM é›†æˆï¼‰

```go
// é…ç½® LLMï¼ˆè®© MCP Server èƒ½è°ƒç”¨ LLMï¼‰
llm := openai.New(openai.Config{
    APIKey: os.Getenv("OPENAI_API_KEY"),
    Model:  "gpt-4",
})

server.SetLLM(llm)

// MCP Client å¯ä»¥è¯·æ±‚ Server ä½¿ç”¨ LLM ç”Ÿæˆå†…å®¹
// Server ä¼šè‡ªåŠ¨å¤„ç†é‡‡æ ·è¯·æ±‚
```

#### 6. ä¼ è¾“å±‚é€‰æ‹©

```go
// Stdio ä¼ è¾“ï¼ˆé€‚åˆæœ¬åœ°è¿›ç¨‹ï¼‰
stdioTransport := mcp.NewStdioTransport()
server.Serve(ctx, stdioTransport)

// SSE ä¼ è¾“ï¼ˆHTTP Server-Sent Eventsï¼‰
sseTransport := mcp.NewSSETransport(mcp.SSEConfig{
    Port: 8080,
    Path: "/mcp",
})
server.Serve(ctx, sseTransport)

// WebSocket ä¼ è¾“
wsTransport := mcp.NewWebSocketTransport(mcp.WebSocketConfig{
    Port: 8080,
    Path: "/ws",
})
server.Serve(ctx, wsTransport)
```

---

### MCP Client ä½¿ç”¨

#### 1. è¿æ¥åˆ° MCP Server

```go
// åˆ›å»º Client
client := mcp.NewClient(mcp.ClientConfig{
    Name:    "my-client",
    Version: "1.0.0",
    Timeout: 30 * time.Second,
})

// è¿æ¥åˆ° Serverï¼ˆStdioï¼‰
err := client.Connect(ctx, "stdio://path/to/server")

// è¿æ¥åˆ° Serverï¼ˆHTTP SSEï¼‰
err := client.Connect(ctx, "http://localhost:8080/mcp")

// è¿æ¥åˆ° Serverï¼ˆWebSocketï¼‰
err := client.Connect(ctx, "ws://localhost:8080/ws")
```

#### 2. åˆ—å‡ºå’Œè¯»å–èµ„æº

```go
// åˆ—å‡ºæ‰€æœ‰èµ„æº
resources, err := client.ListResources(ctx)
for _, res := range resources {
    fmt.Printf("èµ„æº: %s (%s)\n", res.Name, res.URI)
}

// è¯»å–èµ„æºå†…å®¹
content, err := client.ReadResource(ctx, "file:///documents/guide.txt")
fmt.Println(content.Text)

// è®¢é˜…èµ„æºæ›´æ–°
client.OnResourceUpdated(func(update *mcp.ResourceUpdate) {
    fmt.Printf("èµ„æº %s å·²æ›´æ–°\n", update.URI)
    
    // é‡æ–°è¯»å–èµ„æº
    content, _ := client.ReadResource(ctx, update.URI)
    // å¤„ç†æ–°å†…å®¹...
})
```

#### 3. è°ƒç”¨å·¥å…·

```go
// åˆ—å‡ºæ‰€æœ‰å·¥å…·
tools, err := client.ListTools(ctx)
for _, tool := range tools {
    fmt.Printf("å·¥å…·: %s - %s\n", tool.Name, tool.Description)
}

// è°ƒç”¨å·¥å…·
result, err := client.CallTool(ctx, "calculator", map[string]any{
    "expression": "2 + 3 * 4",
})

if result.IsError {
    fmt.Printf("é”™è¯¯: %s\n", result.Content[0].Text)
} else {
    fmt.Printf("ç»“æœ: %s\n", result.Content[0].Text)
}
```

#### 4. è·å– Prompt

```go
// åˆ—å‡ºæ‰€æœ‰ Prompts
prompts, err := client.ListPrompts(ctx)

// è·å– Prompt
promptResult, err := client.GetPrompt(ctx, "code_review", map[string]any{
    "code":     "func main() { ... }",
    "language": "go",
})

fmt.Println(promptResult.Prompt)
```

---

### ä¸ Claude Desktop é›†æˆ

#### 1. é…ç½® Claude Desktop

**macOS/Linux**: ç¼–è¾‘ `~/.config/claude/claude_desktop_config.json`

**Windows**: ç¼–è¾‘ `%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "langchain-go": {
      "command": "/path/to/your/mcp_server",
      "args": [],
      "env": {
        "OPENAI_API_KEY": "sk-...",
        "DATABASE_URL": "postgresql://..."
      }
    },
    "company-tools": {
      "command": "/usr/local/bin/company_mcp_server",
      "args": ["--config", "/etc/mcp/config.yaml"]
    }
  }
}
```

#### 2. æ„å»º MCP Server

```bash
# æ„å»ºå¯æ‰§è¡Œæ–‡ä»¶
cd your_mcp_server
go build -o mcp_server main.go

# ç¡®ä¿å¯æ‰§è¡Œ
chmod +x mcp_server

# æµ‹è¯•è¿è¡Œ
./mcp_server
```

#### 3. é‡å¯ Claude Desktop

é‡å¯ Claude Desktop åï¼Œå®ƒä¼šè‡ªåŠ¨è¿æ¥åˆ°é…ç½®çš„ MCP Serversã€‚

#### 4. åœ¨ Claude ä¸­ä½¿ç”¨

åœ¨ Claude Desktop çš„å¯¹è¯ä¸­ï¼š

```
ä½ ï¼šåˆ—å‡ºå¯ç”¨çš„å·¥å…·

Claudeï¼šæˆ‘ç°åœ¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·ï¼š
- calculatorï¼šæ•°å­¦è®¡ç®—
- file_readerï¼šè¯»å–æ–‡ä»¶
- database_queryï¼šæŸ¥è¯¢æ•°æ®åº“
...

ä½ ï¼šä½¿ç”¨ calculator è®¡ç®— 25 çš„å¹³æ–¹æ ¹

Claudeï¼šï¼ˆè°ƒç”¨å·¥å…·ï¼‰è®¡ç®—ç»“æœæ˜¯ 5.0

ä½ ï¼šè¯»å– /docs/guide.txt æ–‡ä»¶

Claudeï¼šï¼ˆè°ƒç”¨å·¥å…·ï¼‰æ–‡ä»¶å†…å®¹æ˜¯...
```

#### 5. è°ƒè¯•

æŸ¥çœ‹ Claude Desktop æ—¥å¿—ï¼š

```bash
# macOS
tail -f ~/Library/Logs/Claude/mcp.log

# Linux
tail -f ~/.config/Claude/logs/mcp.log

# Windows
type %APPDATA%\Claude\logs\mcp.log
```

---

## A2A åè®®ä½¿ç”¨

### A2A å¿«é€Ÿå¼€å§‹

#### 5 åˆ†é’Ÿåˆ›å»ºç¬¬ä¸€ä¸ª A2A Agent

```go
package main

import (
    "context"
    "log"
    
    "github.com/zhucl121/langchain-go/pkg/protocols/a2a"
    "github.com/zhucl121/langchain-go/core/agents"
)

func main() {
    // 1. åˆ›å»ºä¸€ä¸ªç°æœ‰çš„ Agent
    myAgent := agents.CreateReActAgent(llm, tools)
    
    // 2. æ¡¥æ¥ä¸º A2A Agent
    a2aAgent := a2a.NewA2AAgentBridge(myAgent, &a2a.BridgeConfig{
        Info: &a2a.AgentInfo{
            ID:          "agent-1",
            Name:        "Research Agent",
            Description: "ä¸“é—¨è´Ÿè´£ç ”ç©¶å’Œä¿¡æ¯æ”¶é›†",
            Type:        a2a.AgentTypeSpecialist,
        },
        Capabilities: &a2a.AgentCapabilities{
            Capabilities: []string{"research", "search", "analysis"},
            Tools:        []string{"search", "web_scraper"},
            Languages:    []string{"zh", "en"},
        },
    })
    
    // 3. æ³¨å†Œåˆ°æ³¨å†Œä¸­å¿ƒ
    registry := a2a.NewLocalRegistry()  // å¼€å‘/æµ‹è¯•ç”¨æœ¬åœ°æ³¨å†Œ
    // registry := a2a.NewConsulRegistry(consulConfig)  // ç”Ÿäº§ç¯å¢ƒç”¨ Consul
    
    if err := registry.Register(context.Background(), a2aAgent); err != nil {
        log.Fatal(err)
    }
    
    log.Println("A2A Agent æ³¨å†ŒæˆåŠŸ")
    
    // ä¿æŒè¿è¡Œ
    select {}
}
```

---

### Agent æ³¨å†Œä¸å‘ç°

#### 1. ä½¿ç”¨ Consul æ³¨å†Œä¸­å¿ƒï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰

```go
// åˆ›å»º Consul æ³¨å†Œä¸­å¿ƒ
consulConfig := &api.Config{
    Address: "localhost:8500",
    Scheme:  "http",
}

registry := a2a.NewConsulRegistry(consulConfig)

// æ³¨å†Œ Agent
agent := a2a.NewA2AAgentBridge(myAgent, bridgeConfig)
registry.Register(ctx, agent)

// å®šæœŸå‘é€å¿ƒè·³
go func() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        registry.Heartbeat(ctx, agent.GetInfo(ctx).ID)
    }
}()
```

#### 2. Agent å‘ç°

```go
// æŒ‰ ID æŸ¥æ‰¾
agent, err := registry.FindByID(ctx, "agent-1")

// æŒ‰èƒ½åŠ›æŸ¥æ‰¾
agents, err := registry.FindByCapability(ctx, "research")
fmt.Printf("æ‰¾åˆ° %d ä¸ªå…·æœ‰ç ”ç©¶èƒ½åŠ›çš„ Agent\n", len(agents))

// æŒ‰ç±»å‹æŸ¥æ‰¾
specialists, err := registry.FindByType(ctx, a2a.AgentTypeSpecialist)

// åˆ—å‡ºæ‰€æœ‰ Agent
allAgents, err := registry.ListAll(ctx)
```

#### 3. å¥åº·æ£€æŸ¥

```go
// æ£€æŸ¥ Agent å¥åº·çŠ¶æ€
health, err := registry.CheckHealth(ctx, "agent-1")
fmt.Printf("Agent çŠ¶æ€: %s, å»¶è¿Ÿ: %v\n", health.Status, health.Latency)

// è‡ªåŠ¨å¥åº·ç›‘æ§
monitor := a2a.NewHealthMonitor(registry, a2a.HealthMonitorConfig{
    CheckInterval: 30 * time.Second,
    Timeout:       5 * time.Second,
})

monitor.OnAgentUnhealthy(func(agentID string) {
    log.Printf("Agent %s ä¸å¥åº·ï¼Œæ ‡è®°ä¸ºç¦»çº¿", agentID)
    registry.UpdateStatus(ctx, agentID, a2a.AgentStatusOffline)
})

monitor.Start(ctx)
```

---

### ä»»åŠ¡è·¯ç”±

#### 1. åˆ›å»ºä»»åŠ¡

```go
// åˆ›å»ºä¸€ä¸ªä»»åŠ¡
task := &a2a.Task{
    ID:   uuid.New().String(),
    Type: a2a.TaskTypeAnalyze,
    Priority: a2a.PriorityHigh,
    Input: &a2a.TaskInput{
        Type:    "text",
        Content: "åˆ†æè¿™ä¸ªæ•°æ®é›†çš„ç»Ÿè®¡ç‰¹å¾",
    },
    Requirements: &a2a.TaskRequirements{
        Quality:       "high",
        MaxDuration:   300,  // 5 åˆ†é’Ÿ
        RequiredTools: []string{"data_analysis", "statistics"},
    },
    Deadline: &deadline,
}
```

#### 2. æ™ºèƒ½è·¯ç”±

```go
// åˆ›å»ºè·¯ç”±å™¨
router := a2a.NewSmartTaskRouter(registry, a2a.RouterConfig{
    Strategy: a2a.StrategyHybrid,  // æ··åˆç­–ç•¥
    Scorer: &a2a.AgentScorer{
        Weights: &a2a.ScoringWeights{
            CapabilityMatch: 0.4,  // èƒ½åŠ›åŒ¹é… 40%
            Load:            0.3,  // è´Ÿè½½ 30%
            Performance:     0.2,  // æ€§èƒ½ 20%
            Reputation:      0.1,  // ä¿¡èª‰ 10%
        },
    },
})

// è·¯ç”±ä»»åŠ¡åˆ°æœ€åˆé€‚çš„ Agent
agent, err := router.Route(ctx, task)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("ä»»åŠ¡è·¯ç”±åˆ°: %s\n", agent.GetInfo(ctx).Name)

// å‘é€ä»»åŠ¡
response, err := agent.SendTask(ctx, task)
```

#### 3. è·¯ç”±ç­–ç•¥

```go
// èƒ½åŠ›åŒ¹é…ç­–ç•¥ï¼ˆé»˜è®¤ï¼‰
router := a2a.NewSmartTaskRouter(registry, a2a.RouterConfig{
    Strategy: a2a.StrategyCapability,
})

// è´Ÿè½½å‡è¡¡ç­–ç•¥
router := a2a.NewSmartTaskRouter(registry, a2a.RouterConfig{
    Strategy: a2a.StrategyLoad,
})

// æ€§èƒ½ä¼˜å…ˆç­–ç•¥
router := a2a.NewSmartTaskRouter(registry, a2a.RouterConfig{
    Strategy: a2a.StrategyPerformance,
})

// æ··åˆç­–ç•¥ï¼ˆæ¨èï¼‰
router := a2a.NewSmartTaskRouter(registry, a2a.RouterConfig{
    Strategy: a2a.StrategyHybrid,
})
```

#### 4. è´Ÿè½½å‡è¡¡è·¯ç”±

```go
// è·¯ç”±å¤šä¸ªä»»åŠ¡åˆ°ä¸åŒ Agent
tasks := []*a2a.Task{task1, task2, task3, task4, task5}

for _, task := range tasks {
    agent, err := router.RouteWithLoadBalancing(ctx, task)
    if err != nil {
        log.Printf("è·¯ç”±å¤±è´¥: %v", err)
        continue
    }
    
    // å¼‚æ­¥å‘é€ä»»åŠ¡
    go func(t *a2a.Task, a a2a.A2AAgent) {
        resp, err := a.SendTask(ctx, t)
        // å¤„ç†å“åº”...
    }(task, agent)
}
```

---

### å¤š Agent åä½œ

#### 1. ä½¿ç”¨åä½œåè°ƒå™¨

```go
// åˆ›å»ºåè°ƒå™¨
coordinator := a2a.NewCollaborationCoordinator(registry, router)

// å®šä¹‰å¤æ‚ä»»åŠ¡
complexTask := &a2a.Task{
    ID:   uuid.New().String(),
    Type: a2a.TaskTypeComplex,
    Input: &a2a.TaskInput{
        Type:    "text",
        Content: "ç ”ç©¶ AI æœ€æ–°è¿›å±•ï¼Œåˆ†æè¶‹åŠ¿ï¼Œæ’°å†™æŠ¥å‘Š",
    },
}

// è‡ªåŠ¨åè°ƒå¤š Agent å®Œæˆ
result, err := coordinator.Coordinate(ctx, complexTask)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("æœ€ç»ˆç»“æœ: %s\n", result.Content)
```

#### 2. ä»»åŠ¡åˆ†è§£å’Œèšåˆ

```go
// åè°ƒå™¨ä¼šè‡ªåŠ¨ï¼š
// 1. åˆ†è§£ä»»åŠ¡ä¸ºå­ä»»åŠ¡
// 2. ä¸ºæ¯ä¸ªå­ä»»åŠ¡æ‰¾åˆ°åˆé€‚çš„ Agent
// 3. å¹¶è¡Œæ‰§è¡Œå­ä»»åŠ¡
// 4. èšåˆç»“æœ

// æŸ¥çœ‹åä½œä¼šè¯
session := coordinator.GetSession(complexTask.ID)
fmt.Printf("å‚ä¸ Agent: %d ä¸ª\n", len(session.Participants))
fmt.Printf("å­ä»»åŠ¡: %d ä¸ª\n", len(session.SubTasks))

for agentID, agent := range session.Participants {
    info, _ := agent.GetInfo(ctx)
    fmt.Printf("- %s (%s)\n", info.Name, agentID)
}
```

#### 3. ååŠ©è¯·æ±‚

```go
// Agent å¯ä»¥è¯·æ±‚å…¶ä»– Agent ååŠ©
helpRequest := &a2a.HelpRequest{
    RequestID:   uuid.New().String(),
    RequesterID: "agent-1",
    Task:        difficultTask,
    Reason:      "éœ€è¦ä¸“ä¸šçš„æ•°æ®åˆ†æèƒ½åŠ›",
    Requirements: &a2a.HelpRequirements{
        RequiredCapabilities: []string{"data_analysis", "statistics"},
        MaxWaitTime:          30 * time.Second,
    },
}

// å‘é€ååŠ©è¯·æ±‚
response, err := agent.RequestHelp(ctx, helpRequest)
if err != nil {
    log.Printf("æ²¡æœ‰ Agent å¯ä»¥ååŠ©: %v", err)
    return
}

fmt.Printf("Agent %s æä¾›ååŠ©\n", response.HelperID)
```

---

## åè®®æ¡¥æ¥

### MCP â†’ A2A æ¡¥æ¥

```go
// åˆ›å»ºæ¡¥æ¥
bridge := bridge.NewMCPToA2ABridge(mcpServer, a2aAgent)

// MCP å·¥å…·è°ƒç”¨è‡ªåŠ¨è½¬æ¢ä¸º A2A ä»»åŠ¡
mcpServer.OnToolCall(func(call *mcp.ToolCall) (*mcp.ToolResult, error) {
    // è½¬æ¢ä¸º A2A ä»»åŠ¡
    task := bridge.ToolCallToTask(call)
    
    // è·¯ç”±åˆ°åˆé€‚çš„ A2A Agent
    agent, _ := router.Route(context.Background(), task)
    
    // æ‰§è¡Œä»»åŠ¡
    response, err := agent.SendTask(context.Background(), task)
    if err != nil {
        return nil, err
    }
    
    // è½¬æ¢å› MCP å·¥å…·ç»“æœ
    return bridge.TaskResponseToToolResult(response), nil
})
```

### A2A â†’ MCP æ¡¥æ¥

```go
// åˆ›å»ºæ¡¥æ¥
bridge := bridge.NewA2AToMCPBridge(a2aAgent, mcpClient)

// å°† A2A Agent èƒ½åŠ›æš´éœ²ä¸º MCP èµ„æº
resources, err := bridge.ExposeAsResources()
for _, res := range resources {
    fmt.Printf("èµ„æº: %s -> A2A Agent èƒ½åŠ›\n", res.URI)
}

// åœ¨ MCP Server ä¸­æ³¨å†Œè¿™äº›èµ„æº
for _, res := range resources {
    mcpServer.RegisterResource(res, bridge.CreateProvider(res))
}
```

---

## æœ€ä½³å®è·µ

### MCP æœ€ä½³å®è·µ

#### 1. èµ„æºå®‰å…¨

```go
// ä½¿ç”¨ RBAC æ§åˆ¶èµ„æºè®¿é—®ï¼ˆé›†æˆ v0.6.0ï¼‰
server := mcp.NewServer(mcp.ServerConfig{
    Auth: mcp.AuthConfig{
        Enabled: true,
        RBAC:    rbacManager,
    },
})

// ä¸ºèµ„æºè®¾ç½®è®¿é—®æ§åˆ¶
resource := &mcp.Resource{
    URI:  "db://sensitive_data",
    Name: "Sensitive Data",
    Metadata: map[string]any{
        "rbac_resource": "database",
        "rbac_action":   "read",
    },
}
```

#### 2. èµ„æºç»„ç»‡

```go
// æŒ‰ç±»å‹ç»„ç»‡èµ„æº
// file:// - æ–‡ä»¶ç³»ç»Ÿ
// db:// - æ•°æ®åº“
// vector:// - å‘é‡å­˜å‚¨
// api:// - API ç«¯ç‚¹
// github:// - GitHub ä»“åº“

// ä½¿ç”¨å±‚æ¬¡ç»“æ„
// file:///company/docs/public
// file:///company/docs/internal
// db://company/customers
// db://company/orders
```

#### 3. é”™è¯¯å¤„ç†

```go
// è¿”å›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
if err != nil {
    return &mcp.ToolResult{
        IsError: true,
        Content: []mcp.ContentBlock{
            {
                Type: "text",
                Text: fmt.Sprintf("é”™è¯¯: %v\nå»ºè®®: æ£€æŸ¥è¾“å…¥å‚æ•°æ˜¯å¦æ­£ç¡®", err),
            },
        },
    }, nil
}
```

#### 4. æ€§èƒ½ä¼˜åŒ–

```go
// ä½¿ç”¨èµ„æºè®¢é˜…è€Œéè½®è¯¢
client.SubscribeResource(ctx, "file:///logs", func(update *mcp.ResourceUpdate) {
    // åªåœ¨æ›´æ–°æ—¶å¤„ç†
})

// æ‰¹é‡æ“ä½œ
resources, _ := client.ListResources(ctx)
var wg sync.WaitGroup
for _, res := range resources {
    wg.Add(1)
    go func(r *mcp.Resource) {
        defer wg.Done()
        content, _ := client.ReadResource(ctx, r.URI)
        // å¤„ç†å†…å®¹...
    }(res)
}
wg.Wait()
```

---

### A2A æœ€ä½³å®è·µ

#### 1. èƒ½åŠ›æ˜ç¡®

```go
// å‡†ç¡®å®šä¹‰ Agent èƒ½åŠ›
capabilities := &a2a.AgentCapabilities{
    Capabilities: []string{
        "text_generation",      // æ–‡æœ¬ç”Ÿæˆ
        "code_writing",         // ä»£ç ç¼–å†™
        "data_analysis",        // æ•°æ®åˆ†æ
    },
    Tools: []string{
        "openai_gpt4",          // ä½¿ç”¨çš„æ¨¡å‹
        "python_executor",      // Python æ‰§è¡Œå™¨
        "data_visualizer",      // æ•°æ®å¯è§†åŒ–
    },
    Languages: []string{"zh", "en"},
    MaxConcurrentTasks: 5,
    AvgResponseTime:    2 * time.Second,
}
```

#### 2. å¥åº·ç›‘æ§

```go
// å®šæœŸå‘é€å¿ƒè·³
go func() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()
    
    for range ticker.C {
        if err := registry.Heartbeat(ctx, agentID); err != nil {
            log.Printf("å¿ƒè·³å¤±è´¥: %v", err)
        }
    }
}()

// ä¼˜é›…å…³é—­
defer func() {
    registry.UpdateStatus(ctx, agentID, a2a.AgentStatusOffline)
    registry.Unregister(ctx, agentID)
}()
```

#### 3. ä»»åŠ¡è¶…æ—¶

```go
// è®¾ç½®ä»»åŠ¡è¶…æ—¶
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
defer cancel()

response, err := agent.SendTask(ctx, task)
if err == context.DeadlineExceeded {
    log.Println("ä»»åŠ¡è¶…æ—¶")
}
```

#### 4. é”™è¯¯é‡è¯•

```go
// ä½¿ç”¨é‡è¯•æœºåˆ¶
maxRetries := 3
var response *a2a.TaskResponse
var err error

for i := 0; i < maxRetries; i++ {
    response, err = agent.SendTask(ctx, task)
    if err == nil {
        break
    }
    
    log.Printf("å°è¯• %d/%d å¤±è´¥: %v", i+1, maxRetries, err)
    time.Sleep(time.Second * time.Duration(i+1))  // æŒ‡æ•°é€€é¿
}
```

---

## æ•…éšœæ’æŸ¥

### MCP å¸¸è§é—®é¢˜

#### 1. Claude Desktop æ— æ³•è¿æ¥

**ç—‡çŠ¶**: Claude Desktop æœªæ˜¾ç¤º MCP Server

**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ£€æŸ¥é…ç½®æ–‡ä»¶
cat ~/.config/claude/claude_desktop_config.json

# æ£€æŸ¥å¯æ‰§è¡Œæ–‡ä»¶
ls -l /path/to/mcp_server
./mcp_server  # æ‰‹åŠ¨è¿è¡Œæµ‹è¯•

# æŸ¥çœ‹æ—¥å¿—
tail -f ~/Library/Logs/Claude/mcp.log
```

#### 2. å·¥å…·è°ƒç”¨å¤±è´¥

**ç—‡çŠ¶**: å·¥å…·è¿”å›é”™è¯¯æˆ–è¶…æ—¶

**è§£å†³æ–¹æ¡ˆ**:
```go
// å¢åŠ è¶…æ—¶æ—¶é—´
config := mcp.ClientConfig{
    Timeout: 60 * time.Second,  // å¢åŠ åˆ° 60 ç§’
}

// æ·»åŠ é‡è¯•é€»è¾‘
// æ£€æŸ¥å·¥å…·å‚æ•°æ˜¯å¦æ­£ç¡®
```

#### 3. èµ„æºè¯»å–å¤±è´¥

**ç—‡çŠ¶**: æ— æ³•è¯»å–èµ„æºå†…å®¹

**è§£å†³æ–¹æ¡ˆ**:
```go
// æ£€æŸ¥èµ„æº URI æ˜¯å¦æ­£ç¡®
// æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦å­˜åœ¨
// æ£€æŸ¥æƒé™æ˜¯å¦è¶³å¤Ÿ

// æ·»åŠ è¯¦ç»†æ—¥å¿—
log.Printf("è¯»å–èµ„æº: %s", uri)
content, err := provider.Read(ctx, uri)
if err != nil {
    log.Printf("è¯»å–å¤±è´¥: %v", err)
}
```

---

### A2A å¸¸è§é—®é¢˜

#### 1. Agent æ³¨å†Œå¤±è´¥

**ç—‡çŠ¶**: Agent æ— æ³•æ³¨å†Œåˆ° Consul

**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ£€æŸ¥ Consul æ˜¯å¦è¿è¡Œ
docker ps | grep consul
curl http://localhost:8500/v1/status/leader

# æ£€æŸ¥ç½‘ç»œè¿æ¥
ping localhost

# æŸ¥çœ‹ Consul æ—¥å¿—
docker logs consul
```

#### 2. ä»»åŠ¡è·¯ç”±å¤±è´¥

**ç—‡çŠ¶**: æ‰¾ä¸åˆ°åˆé€‚çš„ Agent

**è§£å†³æ–¹æ¡ˆ**:
```go
// æ£€æŸ¥ Agent èƒ½åŠ›æ˜¯å¦åŒ¹é…
agents, _ := registry.FindByCapability(ctx, "required_capability")
fmt.Printf("æ‰¾åˆ° %d ä¸ªåŒ¹é…çš„ Agent\n", len(agents))

// é™ä½ä»»åŠ¡è¦æ±‚
task.Requirements = &a2a.TaskRequirements{
    RequiredTools: []string{},  // ä¸è¦æ±‚ç‰¹å®šå·¥å…·
}

// ä½¿ç”¨ä¸åŒçš„è·¯ç”±ç­–ç•¥
router.SetStrategy(a2a.StrategyLoad)  // åªçœ‹è´Ÿè½½
```

#### 3. Agent é€šä¿¡è¶…æ—¶

**ç—‡çŠ¶**: Agent é—´é€šä¿¡è¶…æ—¶

**è§£å†³æ–¹æ¡ˆ**:
```go
// å¢åŠ è¶…æ—¶æ—¶é—´
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)

// æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿ
health, _ := registry.CheckHealth(ctx, agentID)
fmt.Printf("å»¶è¿Ÿ: %v\n", health.Latency)

// ä½¿ç”¨æ›´å¿«çš„ä¼ è¾“å±‚ï¼ˆgRPCï¼‰
```

---

## æ›´å¤šèµ„æº

- [MCP è§„èŒƒ](./V0.6.1_MCP_SPEC.md) - å®Œæ•´çš„ MCP åè®®è§„èŒƒ
- [A2A è§„èŒƒ](./V0.6.1_A2A_SPEC.md) - å®Œæ•´çš„ A2A åè®®è§„èŒƒ
- [é›†æˆæŒ‡å—](./V0.6.1_INTEGRATION_GUIDE.md) - ä¸å…¶ä»–å·¥å…·é›†æˆ
- [API å‚è€ƒ](./V0.6.1_API_REFERENCE.md) - å®Œæ•´çš„ API æ–‡æ¡£
- [ç¤ºä¾‹ä»£ç ](../examples/) - 7 ä¸ªå®Œæ•´ç¤ºä¾‹

---

**åˆ›å»ºæ—¥æœŸ**: 2026-01-22  
**æœ€åæ›´æ–°**: 2026-01-22  
**ç‰ˆæœ¬**: v0.6.1
