# LangChain-Go v0.3.0 ç”¨æˆ·æŒ‡å—

**ç‰ˆæœ¬**: v0.3.0  
**å‘å¸ƒæ—¥æœŸ**: 2026-01-20  
**ä¸»é¢˜**: ä¼ä¸šç‰¹æ€§

---

## ğŸ“‹ ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [å¤šæ¨¡æ€æ”¯æŒ](#å¤šæ¨¡æ€æ”¯æŒ)
- [RBAC ç³»ç»Ÿ](#rbac-ç³»ç»Ÿ)
- [Human-in-the-Loop å¢å¼º](#human-in-the-loop-å¢å¼º)
- [å®Œæ•´ç¤ºä¾‹](#å®Œæ•´ç¤ºä¾‹)
- [éƒ¨ç½²æŒ‡å—](#éƒ¨ç½²æŒ‡å—)

---

## æ¦‚è¿°

v0.3.0 å¼•å…¥äº†ä¸‰å¤§ä¼ä¸šçº§ç‰¹æ€§ï¼š

1. **å¤šæ¨¡æ€æ”¯æŒ** - å¤„ç†å›¾åƒã€éŸ³é¢‘ã€è§†é¢‘
2. **RBAC ç³»ç»Ÿ** - æƒé™æ§åˆ¶å’Œå¤šç§Ÿæˆ·
3. **HITL å¢å¼º** - å®¡æ‰¹å·¥ä½œæµå’Œå†³ç­–å›æ»š

---

## å¤šæ¨¡æ€æ”¯æŒ

### å¿«é€Ÿå¼€å§‹

#### 1. å›¾åƒå¤„ç†

```go
package main

import (
    "context"
    "github.com/zhucl121/langchain-go/pkg/types"
    "github.com/zhucl121/langchain-go/retrieval/embeddings"
)

func main() {
    // åŠ è½½å›¾åƒ
    imageContent, _ := types.NewImageContentFromFile("photo.jpg")
    
    // åˆ›å»ºå›¾åƒåµŒå…¥å™¨
    imageEmbed := embeddings.NewMockImageEmbedder(512)
    
    // ç”Ÿæˆå‘é‡
    ctx := context.Background()
    imageData, _ := imageContent.GetImageData()
    vector, _ := imageEmbed.EmbedImage(ctx, imageData)
    
    println("å›¾åƒå‘é‡ç»´åº¦:", len(vector))
}
```

#### 2. è·¨æ¨¡æ€æ£€ç´¢

```go
// åˆ›å»º CLIP åµŒå…¥å™¨
textEmbed := embeddings.NewOpenAIEmbeddings(config)
imageEmbed := embeddings.NewOpenAIVisionEmbedder(visionConfig)

clipEmbed := embeddings.NewCLIPEmbedder(textEmbed, imageEmbed, 512, "clip")

// æ–‡æœ¬æœå›¾åƒ
indices, scores, _ := clipEmbed.SearchImageByText(
    ctx,
    "cute cat",
    imageEmbeddings,
    10,
)

// å›¾åƒæœæ–‡æœ¬
indices, scores, _ := clipEmbed.SearchTextByImage(
    ctx,
    imageData,
    textEmbeddings,
    10,
)
```

#### 3. éŸ³é¢‘å¤„ç†

```go
// åˆ›å»º Whisper åµŒå…¥å™¨
whisper := embeddings.NewWhisperEmbedder(config, textEmbedder)

// è½¬å½•éŸ³é¢‘
audioContent, _ := types.NewAudioContentFromFile("audio.mp3")
audioData, _ := audioContent.GetAudioData()
text, _ := whisper.Transcribe(ctx, audioData)

println("è½¬å½•:", text)

// å¸¦æ—¶é—´æˆ³çš„è½¬å½•
result, _ := whisper.TranscribeWithTimestamps(ctx, audioData)
for _, word := range result.Words {
    fmt.Printf("[%.2f-%.2f] %s\n", word.Start, word.End, word.Word)
}

// éŸ³é¢‘å‘é‡åŒ–
vector, _ := whisper.EmbedAudio(ctx, audioData)
```

#### 4. è§†é¢‘å¤„ç†

```go
// åˆ›å»ºè§†é¢‘åµŒå…¥å™¨
videoConfig := embeddings.DefaultVideoEmbedderConfig()
videoEmbed := embeddings.NewVideoEmbedder(videoConfig, imageEmbed)

// è§†é¢‘å‘é‡åŒ–
videoContent, _ := types.NewVideoContentFromFile("video.mp4")
videoData, _ := videoContent.GetVideoData()
vector, _ := videoEmbed.EmbedVideo(ctx, videoData)
```

#### 5. å¤šæ¨¡æ€æ–‡æ¡£

```go
// åˆ›å»ºå¤šæ¨¡æ€æ–‡æ¡£
doc := loaders.NewMultimodalDocument("product_001",
    types.NewTextContent("iPhone 15 Pro"),
    imageContent,
    audioContent,
)

// æŸ¥è¯¢å†…å®¹
if doc.HasImages() {
    images := doc.GetImageContents()
    println("åŒ…å«", len(images), "å¼ å›¾ç‰‡")
}

// è½¬æ¢ä¸ºæ™®é€šæ–‡æ¡£ï¼ˆå‘åå…¼å®¹ï¼‰
textDoc := doc.ToDocument()
```

---

## RBAC ç³»ç»Ÿ

### å¿«é€Ÿå¼€å§‹

#### 1. åˆ›å»ºè§’è‰²å’Œç”¨æˆ·

```go
import "github.com/zhucl121/langchain-go/pkg/auth"

// åˆ›å»º RBAC ç®¡ç†å™¨
rbacMgr := auth.NewInMemoryRBACManager()

// åˆ›å»ºè‡ªå®šä¹‰è§’è‰²
role := &auth.Role{
    Name: "data_scientist",
    Description: "æ•°æ®ç§‘å­¦å®¶è§’è‰²",
    Permissions: []auth.Permission{
        {Resource: auth.ResourceVectorStore, Action: auth.ActionRead},
        {Resource: auth.ResourceVectorStore, Action: auth.ActionWrite},
        {Resource: auth.ResourceAgent, Action: auth.ActionExecute},
    },
}
rbacMgr.CreateRole(ctx, role)

// åˆ›å»ºç”¨æˆ·
user := &auth.User{
    ID: "user123",
    Name: "å¼ ä¸‰",
    Email: "zhangsan@example.com",
    TenantID: "tenant001",
    Roles: []string{"data_scientist"},
}
rbacMgr.CreateUser(ctx, user)

// åˆ†é…é¢å¤–è§’è‰²
rbacMgr.AssignRole(ctx, "user123", "user")
```

#### 2. æƒé™æ£€æŸ¥

```go
// æ£€æŸ¥æƒé™
err := rbacMgr.CheckPermission(ctx, "user123",
    auth.ResourceVectorStore,
    auth.ActionWrite,
    "store001", // å¯é€‰: ç‰¹å®šèµ„æº ID
)

if err == auth.ErrPermissionDenied {
    println("æƒé™è¢«æ‹’ç»")
    return
}

// è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
perms, _ := rbacMgr.GetUserPermissions(ctx, "user123")
for _, perm := range perms {
    println(perm.String())
}
```

#### 3. åœ¨ä¸Šä¸‹æ–‡ä¸­ä¼ é€’è®¤è¯ä¿¡æ¯

```go
// è®¾ç½®è®¤è¯ä¸Šä¸‹æ–‡
ctx = auth.ContextWithAuth(ctx, "user123", "tenant001")

// åœ¨å…¶ä»–åœ°æ–¹æå–
userID, _ := auth.UserFromContext(ctx)
tenantID, _ := auth.TenantFromContext(ctx)
```

### å¤šç§Ÿæˆ·ç®¡ç†

```go
// åˆ›å»ºç§Ÿæˆ·ç®¡ç†å™¨
tenantMgr := auth.NewInMemoryTenantManager()

// åˆ›å»ºç§Ÿæˆ·
tenant := &auth.Tenant{
    ID: "tenant001",
    Name: "Acme Corp",
    Status: auth.TenantStatusActive,
    Quota: &auth.ResourceQuota{
        APICallsPerDay: 10000,
        MaxDocuments: 50000,
        MaxVectors: 1000000,
        MaxStorage: 100 * 1024 * 1024 * 1024, // 100 GB
    },
}
tenantMgr.CreateTenant(ctx, tenant)

// æš‚åœç§Ÿæˆ·
tenantMgr.SuspendTenant(ctx, "tenant001")

// æ¿€æ´»ç§Ÿæˆ·
tenantMgr.ActivateTenant(ctx, "tenant001")
```

### èµ„æºé…é¢ç®¡ç†

```go
// åˆ›å»ºé…é¢ç®¡ç†å™¨
quotaMgr := auth.NewInMemoryQuotaManager(tenantMgr)

// æ£€æŸ¥é…é¢
err := quotaMgr.CheckQuota(ctx, "tenant001",
    auth.ResourceTypeAPICall,
    1,
)

if err == auth.ErrResourceQuotaExceeded {
    println("é…é¢å·²è¶…é™")
    return
}

// è®°å½•ä½¿ç”¨é‡
quotaMgr.IncrementUsage(ctx, "tenant001",
    auth.ResourceTypeAPICall,
    1,
)

// æŸ¥è¯¢ä½¿ç”¨æƒ…å†µ
usage, _ := quotaMgr.GetUsage(ctx, "tenant001")
fmt.Printf("API è°ƒç”¨: %d/%d\n",
    usage.APICallsToday,
    tenant.Quota.APICallsPerDay,
)

// é‡ç½®æ¯æ—¥é…é¢ï¼ˆå®šæ—¶ä»»åŠ¡ï¼‰
quotaMgr.ResetDailyUsage(ctx, "tenant001")
```

---

## Human-in-the-Loop å¢å¼º

### å®¡æ‰¹å·¥ä½œæµ

#### ç®€å•å®¡æ‰¹

```go
import "github.com/zhucl121/langchain-go/graph/hitl"

// åˆ›å»ºå®¡æ‰¹ç®¡ç†å™¨
approvalMgr := hitl.NewApprovalManager()

// åˆ›å»ºå®¡æ‰¹è¯·æ±‚
request := hitl.NewApprovalRequest("req001", "åˆ é™¤æ•°æ®åº“").
    WithOptions("æ‰¹å‡†", "æ‹’ç»")

// è¯·æ±‚å®¡æ‰¹ï¼ˆé˜»å¡ç­‰å¾…ï¼‰
decision, err := approvalMgr.RequestApproval(ctx, request)

if err == hitl.ErrTimeout {
    println("å®¡æ‰¹è¶…æ—¶")
    return
}

if decision.Status == hitl.ApprovalApproved {
    println("å·²æ‰¹å‡†ï¼Œç»§ç»­æ‰§è¡Œ")
    // æ‰§è¡Œæ“ä½œ
} else {
    println("å·²æ‹’ç»ï¼Œä¸­æ­¢æ‰§è¡Œ")
}
```

#### å¤šæ­¥éª¤å·¥ä½œæµ

```go
// åˆ›å»ºå·¥ä½œæµ
workflow := hitl.NewApprovalWorkflow("wf001", "é‡è¦å˜æ›´")

// ç¬¬ä¸€æ­¥: æŠ€æœ¯å®¡æ‰¹
techStep := hitl.NewApprovalStep(
    "tech_review",
    "æŠ€æœ¯å®¡æ‰¹",
    []string{"tech_lead1", "tech_lead2"},
).WithRequiredApprovals(1) // åªéœ€ä¸€äºº

// ç¬¬äºŒæ­¥: ä¸šåŠ¡å®¡æ‰¹
bizStep := hitl.NewApprovalStep(
    "biz_review",
    "ä¸šåŠ¡å®¡æ‰¹",
    []string{"product_manager"},
)

// ç¬¬ä¸‰æ­¥: æœ€ç»ˆå®¡æ‰¹
finalStep := hitl.NewApprovalStep(
    "final_review",
    "æœ€ç»ˆå®¡æ‰¹",
    []string{"vp", "cto"},
).WithRequiredApprovals(1)

workflow.AddStep(techStep)
workflow.AddStep(bizStep)
workflow.AddStep(finalStep)

// å¯åŠ¨å·¥ä½œæµ
engine := hitl.NewWorkflowEngine()
engine.CreateWorkflow(workflow)
engine.StartWorkflow("wf001")

// å„å®¡æ‰¹äººæäº¤å®¡æ‰¹
decision := hitl.NewApprovalDecision("req001", hitl.ApprovalApproved)
engine.SubmitApproval("wf001", "tech_review", "tech_lead1", decision)

// ... æ›´å¤šå®¡æ‰¹ ...

// ç­‰å¾…å·¥ä½œæµå®Œæˆ
completedWorkflow, _ := engine.WaitForWorkflowCompletion(ctx, "wf001")
fmt.Printf("å·¥ä½œæµçŠ¶æ€: %s\n", completedWorkflow.Status)
```

### å†³ç­–å›æ»š

```go
// åˆ›å»ºå›æ»šç®¡ç†å™¨
rollbackMgr := hitl.NewRollbackManager()

// ä¿å­˜å…³é”®èŠ‚ç‚¹çš„å›æ»šç‚¹
checkpoint := saveCheckpoint(state)
point := hitl.NewRollbackPoint(
    "rp_before_delete",
    checkpoint.ID,
    "delete_node",
    state,
)
point.Description = "åˆ é™¤æ“ä½œå‰çš„çŠ¶æ€"
rollbackMgr.SaveRollbackPoint(point)

// ... æ‰§è¡Œæ“ä½œ ...

// å¦‚æœéœ€è¦å›æ»š
if needRollback {
    action := hitl.NewRollbackAction(
        "rp_before_delete",
        "æ“ä½œå¤±è´¥ï¼Œéœ€è¦å›æ»š",
        "admin",
    )
    
    restoredPoint, _ := rollbackMgr.Rollback(ctx, action)
    
    // æ¢å¤çŠ¶æ€
    state = restoredPoint.State.(MyState)
    
    // ä»æ£€æŸ¥ç‚¹æ¢å¤æ‰§è¡Œ
    executor.ResumeFromCheckpoint(ctx, restoredPoint.CheckpointID)
}

// æŸ¥çœ‹å›æ»šå†å²
history := rollbackMgr.GetRollbackHistory()
for _, action := range history {
    fmt.Printf("[%s] %s å›æ»šåˆ° %s: %s\n",
        action.Timestamp.Format(time.RFC3339),
        action.Actor,
        action.TargetPointID,
        action.Reason,
    )
}
```

### äººå·¥å¹²é¢„è®°å½•

```go
// åˆ›å»ºè®°å½•å™¨
recorder := hitl.NewInterventionRecorder()

// è®°å½•å®¡æ‰¹å¹²é¢„
recorder.RecordIntervention(&hitl.InterventionRecord{
    ID:         "ir001",
    Type:       hitl.InterventionTypeApproval,
    WorkflowID: "wf001",
    Actor:      "manager",
    Action:     "æ‰¹å‡†åˆ é™¤æ“ä½œ",
    Before:     oldState,
    After:      newState,
    Reason:     "ç¬¦åˆä¸šåŠ¡éœ€æ±‚",
})

// è®°å½•å›æ»šå¹²é¢„
recorder.RecordIntervention(&hitl.InterventionRecord{
    ID:         "ir002",
    Type:       hitl.InterventionTypeRollback,
    WorkflowID: "wf002",
    Actor:      "admin",
    Action:     "å›æ»šåˆ°å®‰å…¨ç‚¹",
    Reason:     "æ£€æµ‹åˆ°å¼‚å¸¸",
})

// æŸ¥è¯¢å¹²é¢„è®°å½•
// æŒ‰æ“ä½œäºº
managerRecords := recorder.GetRecordsByActor("manager")

// æŒ‰ç±»å‹
approvalRecords := recorder.GetRecordsByType(hitl.InterventionTypeApproval)

// æŒ‰å·¥ä½œæµ
workflowRecords := recorder.GetRecordsByWorkflow("wf001")
```

---

## å®Œæ•´ç¤ºä¾‹

### ç¤ºä¾‹ 1: å¤šæ¨¡æ€ RAG ç³»ç»Ÿ

```go
package main

import (
    "context"
    "github.com/zhucl121/langchain-go/pkg/types"
    "github.com/zhucl121/langchain-go/retrieval/embeddings"
    "github.com/zhucl121/langchain-go/retrieval/loaders"
    "github.com/zhucl121/langchain-go/retrieval/retrievers"
)

func main() {
    ctx := context.Background()
    
    // 1. åˆ›å»ºåµŒå…¥å™¨
    textEmbed := embeddings.NewOpenAIEmbeddings(config)
    imageEmbed := embeddings.NewOpenAIVisionEmbedder(visionConfig)
    audioEmbed := embeddings.NewWhisperEmbedder(whisperConfig, textEmbed)
    
    multimodalEmbed := embeddings.NewBaseMultimodalEmbedder(
        textEmbed, imageEmbed, audioEmbed, nil,
        1536, "multimodal",
    )
    
    // 2. åˆ›å»ºå‘é‡å­˜å‚¨
    vectorStore := vectorstores.NewInMemoryVectorStore(textEmbed)
    
    // 3. åˆ›å»ºå¤šæ¨¡æ€æ£€ç´¢å™¨
    retrieverConfig := retrievers.MultimodalRetrieverConfig{
        VectorStore:        vectorStore,
        MultimodalEmbedder: multimodalEmbed,
        TopK:               10,
        ScoreThreshold:     0.7,
        EnableCrossModal:   true,
    }
    
    retriever, _ := retrievers.NewMultimodalRetriever(retrieverConfig)
    
    // 4. æ·»åŠ å¤šæ¨¡æ€æ–‡æ¡£
    docs := []*loaders.MultimodalDocument{
        loaders.NewMultimodalDocument("doc1",
            types.NewTextContent("äº§å“ä»‹ç»"),
            imageContent,
        ),
    }
    retriever.AddDocuments(ctx, docs)
    
    // 5. æ£€ç´¢
    results, _ := retriever.SearchByText(ctx, "äº§å“å›¾ç‰‡", 5)
    
    for _, doc := range results {
        println("æ‰¾åˆ°æ–‡æ¡£:", doc.ID)
    }
}
```

### ç¤ºä¾‹ 2: å¸¦ RBAC çš„ä¼ä¸šåº”ç”¨

```go
package main

import (
    "context"
    "github.com/zhucl121/langchain-go/pkg/auth"
)

func main() {
    ctx := context.Background()
    
    // 1. åˆå§‹åŒ– RBAC
    rbacMgr := auth.NewInMemoryRBACManager()
    tenantMgr := auth.NewInMemoryTenantManager()
    quotaMgr := auth.NewInMemoryQuotaManager(tenantMgr)
    
    // 2. åˆ›å»ºç§Ÿæˆ·
    tenant := &auth.Tenant{
        ID:   "acme",
        Name: "Acme Corporation",
        Quota: auth.DefaultResourceQuota(),
    }
    tenantMgr.CreateTenant(ctx, tenant)
    
    // 3. åˆ›å»ºç”¨æˆ·
    user := &auth.User{
        ID:       "alice",
        Name:     "Alice",
        TenantID: "acme",
        Roles:    []string{"user"},
    }
    rbacMgr.CreateUser(ctx, user)
    
    // 4. ä½¿ç”¨è®¤è¯ä¸Šä¸‹æ–‡
    authCtx := auth.ContextWithAuth(ctx, "alice", "acme")
    
    // 5. æ‰§è¡Œæ“ä½œå‰æ£€æŸ¥æƒé™
    err := rbacMgr.CheckPermission(authCtx, "alice",
        auth.ResourceVectorStore,
        auth.ActionWrite,
        "store001",
    )
    
    if err != nil {
        println("æƒé™è¢«æ‹’ç»")
        return
    }
    
    // 6. æ£€æŸ¥é…é¢
    err = quotaMgr.CheckQuota(authCtx, "acme",
        auth.ResourceTypeAPICall,
        1,
    )
    
    if err == auth.ErrResourceQuotaExceeded {
        println("é…é¢å·²è¶…é™")
        return
    }
    
    // 7. æ‰§è¡Œæ“ä½œ
    // ... å®é™…ä¸šåŠ¡é€»è¾‘ ...
    
    // 8. è®°å½•ä½¿ç”¨é‡
    quotaMgr.IncrementUsage(authCtx, "acme",
        auth.ResourceTypeAPICall,
        1,
    )
}
```

### ç¤ºä¾‹ 3: å®¡æ‰¹å·¥ä½œæµé›†æˆ

```go
package main

import (
    "context"
    "github.com/zhucl121/langchain-go/graph/hitl"
)

func main() {
    ctx := context.Background()
    
    // 1. åˆ›å»ºå·¥ä½œæµå¼•æ“
    engine := hitl.NewWorkflowEngine()
    rollbackMgr := hitl.NewRollbackManager()
    recorder := hitl.NewInterventionRecorder()
    
    // 2. å®šä¹‰å®¡æ‰¹å·¥ä½œæµ
    workflow := hitl.NewApprovalWorkflow("delete_data", "åˆ é™¤ç”Ÿäº§æ•°æ®")
    
    workflow.AddStep(
        hitl.NewApprovalStep("step1", "æŠ€æœ¯å®¡æ‰¹", []string{"tech_lead"}),
    )
    workflow.AddStep(
        hitl.NewApprovalStep("step2", "ä¸šåŠ¡å®¡æ‰¹", []string{"product_owner"}),
    )
    
    engine.CreateWorkflow(workflow)
    
    // 3. ä¿å­˜å›æ»šç‚¹
    point := hitl.NewRollbackPoint("rp001", checkpointID, "delete", state)
    rollbackMgr.SaveRollbackPoint(point)
    
    // 4. å¯åŠ¨å·¥ä½œæµ
    engine.StartWorkflow("delete_data")
    
    // 5. ç­‰å¾…å®¡æ‰¹
    go func() {
        // æ¨¡æ‹Ÿå®¡æ‰¹äººæäº¤å†³ç­–
        time.Sleep(2 * time.Second)
        decision := hitl.NewApprovalDecision("req001", hitl.ApprovalApproved)
        decision.Comment = "å®¡æ‰¹é€šè¿‡"
        engine.SubmitApproval("delete_data", "step1", "tech_lead", decision)
    }()
    
    // 6. ç­‰å¾…å·¥ä½œæµå®Œæˆ
    completedWorkflow, _ := engine.WaitForWorkflowCompletion(ctx, "delete_data")
    
    if completedWorkflow.Status == hitl.WorkflowStatusApproved {
        // 7. æ‰§è¡Œæ“ä½œ
        println("æ‰§è¡Œåˆ é™¤æ“ä½œ")
        
        // 8. è®°å½•å¹²é¢„
        recorder.RecordIntervention(&hitl.InterventionRecord{
            Type:       hitl.InterventionTypeApproval,
            WorkflowID: "delete_data",
            Actor:      "tech_lead",
            Action:     "æ‰¹å‡†åˆ é™¤",
        })
    } else {
        println("å·¥ä½œæµè¢«æ‹’ç»æˆ–å–æ¶ˆ")
    }
}
```

---

## éƒ¨ç½²æŒ‡å—

### 1. åŸºç¡€éƒ¨ç½²

```bash
# å…‹éš†é¡¹ç›®
git clone https://github.com/zhucl121/langchain-go.git
cd langchain-go

# å®‰è£…ä¾èµ–
go mod download

# è¿è¡Œç¤ºä¾‹
go run examples/multimodal_demo/main.go
```

### 2. ç”Ÿäº§éƒ¨ç½²å»ºè®®

#### æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        è´Ÿè½½å‡è¡¡ (Nginx/HAProxy)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     åº”ç”¨å±‚ (LangChain-Go å®ä¾‹)       â”‚
â”‚  - RBAC æƒé™æ§åˆ¶                     â”‚
â”‚  - é…é¢ç®¡ç†                          â”‚
â”‚  - å®¡æ‰¹å·¥ä½œæµ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PostgreSQLâ”‚  Redis   â”‚ Vector DB     â”‚
â”‚ (æŒä¹…åŒ–)  â”‚ (ç¼“å­˜)   â”‚ (å‘é‡å­˜å‚¨)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### é…ç½®å»ºè®®

**RBAC**:
- ä½¿ç”¨ PostgreSQL æŒä¹…åŒ–è§’è‰²å’Œæƒé™
- ä½¿ç”¨ Redis ç¼“å­˜æƒé™æ£€æŸ¥ç»“æœ
- å®šæœŸå®¡è®¡æƒé™ä½¿ç”¨

**é…é¢ç®¡ç†**:
- ä½¿ç”¨ Redis å­˜å‚¨ä½¿ç”¨é‡ï¼ˆå¿«é€Ÿï¼‰
- å®šæ—¶ä»»åŠ¡é‡ç½®æ¯æ—¥é…é¢
- å‘Šè­¦è¶…é™ç§Ÿæˆ·

**å®¡æ‰¹å·¥ä½œæµ**:
- ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆRabbitMQ/Kafkaï¼‰é€šçŸ¥å®¡æ‰¹äºº
- ä½¿ç”¨ WebSocket å®æ—¶æ¨é€çŠ¶æ€
- æŒä¹…åŒ–å·¥ä½œæµçŠ¶æ€åˆ°æ•°æ®åº“

---

## æœ€ä½³å®è·µ

### 1. å¤šæ¨¡æ€å†…å®¹å¤„ç†

```go
// æ‡’åŠ è½½å¤§æ–‡ä»¶
func loadImageLazy(url string) (*types.MultimodalContent, error) {
    content := types.NewImageContent(url, types.ImageFormatJPEG)
    
    // ä»…åœ¨éœ€è¦æ—¶åŠ è½½æ•°æ®
    return content, nil
}

// ä½¿ç”¨æµå¼åŠ è½½
func loadLargeVideo(filePath string) (*types.MultimodalContent, error) {
    content := &types.MultimodalContent{
        Type: types.ContentTypeVideo,
    }
    
    // ç¨åä½¿ç”¨ LoadFromReader
    file, _ := os.Open(filePath)
    defer file.Close()
    
    content.LoadFromReader(file)
    return content, nil
}
```

### 2. æƒé™ç¼“å­˜

```go
// ä½¿ç”¨ç¼“å­˜å‡å°‘æƒé™æ£€æŸ¥å¼€é”€
type CachedRBACManager struct {
    rbac  auth.RBACManager
    cache map[string]bool
    mu    sync.RWMutex
}

func (m *CachedRBACManager) CheckPermission(ctx context.Context, userID string, resource auth.Resource, action auth.Action, resourceID string) error {
    key := fmt.Sprintf("%s:%s:%s:%s", userID, resource, action, resourceID)
    
    // æ£€æŸ¥ç¼“å­˜
    m.mu.RLock()
    cached, exists := m.cache[key]
    m.mu.RUnlock()
    
    if exists {
        if cached {
            return nil
        }
        return auth.ErrPermissionDenied
    }
    
    // å®é™…æ£€æŸ¥
    err := m.rbac.CheckPermission(ctx, userID, resource, action, resourceID)
    
    // ç¼“å­˜ç»“æœ
    m.mu.Lock()
    m.cache[key] = (err == nil)
    m.mu.Unlock()
    
    return err
}
```

### 3. å®¡æ‰¹è¶…æ—¶å¤„ç†

```go
// è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
request := hitl.NewApprovalRequest("req001", "æ“ä½œ")
request.Timeout = 10 * time.Minute // 10åˆ†é’Ÿ

// è¶…æ—¶åè‡ªåŠ¨å¤„ç†
decision, err := approvalMgr.RequestApproval(ctx, request)
if err == hitl.ErrTimeout {
    // æ ¹æ®ç­–ç•¥å¤„ç†: è‡ªåŠ¨æ‹’ç»æˆ–å‡çº§åˆ°ä¸Šçº§
    escalateToSupervisor(request)
}
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. æ‰¹é‡æƒé™æ£€æŸ¥

```go
func checkBatchPermissions(ctx context.Context, userID string, resources []Resource) error {
    for _, resource := range resources {
        if err := rbacMgr.CheckPermission(ctx, userID, resource, auth.ActionRead, ""); err != nil {
            return err
        }
    }
    return nil
}
```

### 2. é…é¢æ‰¹é‡æ›´æ–°

```go
// æ‰¹é‡å¢åŠ ä½¿ç”¨é‡ï¼ˆå‡å°‘é”ç«äº‰ï¼‰
func batchIncrementUsage(ctx context.Context, tenantID string, operations []Operation) error {
    totalAPICalls := 0
    totalTokens := 0
    
    for _, op := range operations {
        totalAPICalls += op.APICalls
        totalTokens += op.Tokens
    }
    
    quotaMgr.IncrementUsage(ctx, tenantID, auth.ResourceTypeAPICall, int64(totalAPICalls))
    quotaMgr.IncrementUsage(ctx, tenantID, auth.ResourceTypeTokens, int64(totalTokens))
    
    return nil
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2026-01-20  
**ç»´æŠ¤è€…**: LangChain-Go Team
